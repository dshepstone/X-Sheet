<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Animation X-Sheet with Audio Waveform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* General styling */
        body {
            font-family: Arial, sans-serif;
            font-size: 10pt;
            line-height: 1.2;
            margin: 0;
            padding: 10px;
        }

        .controls {
            background-color: #f5f5f5;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .controls select,
        .controls input,
        .controls button {
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .controls button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .controls button:hover {
            background-color: #45a049;
        }

        #pdf-button {
            background-color: #f44336;
        }

        #pdf-button:hover {
            background-color: #d32f2f;
        }

        #print-button {
            background-color: #2196F3;
        }

        #print-button:hover {
            background-color: #0b7dda;
        }

        #audio-button {
            background-color: #9c27b0;
        }

        #audio-button:hover {
            background-color: #7b1fa2;
        }

        .header {
            text-align: center;
            margin-bottom: 5px;
        }

        .title {
            font-size: 14pt;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metadata {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .metadata div {
            border: 1px solid #000;
            padding: 3px 5px;
        }

        .metadata span {
            font-weight: bold;
            margin-right: 5px;
        }

        .metadata input {
            border: none;
            width: 70%;
            font-family: Arial, sans-serif;
            font-size: 9pt;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        th,
        td {
            border: 1px solid #000;
            padding: 2px 4px;
            vertical-align: top;
            height: 20px;
            overflow: hidden;
        }

        th {
            background-color: #eee;
            font-weight: bold;
            text-align: center;
            font-size: 9pt;
        }

        .action-col {
            width: 16%;
        }

        .frame-col {
            width: 4%;
            text-align: center;
        }

        .waveform-col {
            width: 10%;
            padding: 0;
            position: relative;
        }

        .dialogue-col {
            width: 10%;
            text-align: center;
        }

        .sound-col {
            width: 9%;
            text-align: center;
        }

        .technical-col {
            width: 9%;
        }

        .extra1-col {
            width: 8%;
        }

        .extra2-col {
            width: 8%;
        }

        .camera-col {
            width: 12%;
        }

        .waveform-container {
            position: absolute;
            width: 100%;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none;
        }

        .waveform-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 11;
            pointer-events: auto;
            cursor: crosshair;
        }

        .waveform-marker {
            position: absolute;
            width: 100%;
            height: 20px;
            background-color: rgba(255, 255, 0, 0.2);
            pointer-events: none;
            text-align: center;
            font-size: 7pt;
            line-height: 18px;
            color: #666;
            z-index: 20;
        }

        .waveform-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 15;
            pointer-events: none;
        }

        .waveform-col-container {
            position: relative;
        }

        .phonetic-label {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #ccc;
            border-radius: 2px;
            font-size: 7pt;
            padding: 1px 2px;
            z-index: 3;
            pointer-events: none;
        }

        .footer {
            font-size: 8pt;
            text-align: center;
            margin-top: 5px;
            color: #333;
            font-style: italic;
        }

        [contenteditable="true"] {
            min-height: 18px;
            cursor: text;
        }

        [contenteditable="true"]:focus {
            background-color: #f0f7ff;
            outline: none;
        }

        [contenteditable="true"]:empty:before {
            content: attr(data-placeholder);
            color: #888;
            font-style: italic;
        }

        .frame-number {
            background-color: #eee;
            font-weight: bold;
            text-align: center;
        }

        .modified {
            background-color: #fffacd;
        }

        .selected-cell {
            background-color: rgba(0, 123, 255, 0.2) !important;
            outline: 2px solid #0d6efd;
        }

        .status {
            margin-top: 10px;
            padding: 5px;
            background-color: #f0f0f0;
            border-radius: 4px;
            font-style: italic;
            color: #555;
        }

        #audio-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
            margin-top: 5px;
            padding: 5px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }

        #audio-controls button {
            padding: 4px 8px;
            background-color: #673ab7;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        #audio-controls button:hover {
            background-color: #5e35b1;
        }

        #audio-info {
            font-size: 8pt;
            color: #333;
        }

        #phonetic-input {
            position: absolute;
            z-index: 100;
            background: white;
            border: 1px solid #ccc;
            padding: 5px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: none;
        }

        #audio-upload {
            display: none;
        }

        /* Drawing system specific styles */
        .drawing-toolbar button {
            transition: background-color 0.2s, color 0.2s;
        }
        
        .drawing-toolbar button:hover {
            background-color: #e6e6e6 !important;
        }
        
        .drawing-toolbar button.active {
            background-color: #4CAF50 !important;
            color: white !important;
        }
        
        .drawing-layer-container {
            pointer-events: none;
        }
        
        .drawing-layer-container canvas {
            pointer-events: none;
            touch-action: none;
        }

        /* Print specific styles */
        @media print {
            .controls,
            button,
            #frame-count-container,
            .status,
            #audio-controls,
            #phonetic-input,
            .drawing-toolbar {
                display: none !important;
            }

            body {
                margin: 0;
                padding: 0;
            }

            @page {
                size: auto;
                margin: 0.5cm;
            }

            thead {
                display: table-header-group;
            }

            tfoot {
                display: table-footer-group;
            }

            tr {
                page-break-inside: avoid;
            }

            /* Better waveform printing */
            .waveform-col {
                position: relative !important;
                overflow: hidden !important;
            }

            .print-waveform-container {
                display: block !important;
                position: absolute !important;
                z-index: 1000 !important;
                pointer-events: none !important;
                overflow: hidden !important;
            }

            .waveform-col * {
                page-break-inside: avoid !important;
            }

            /* ensure the waveform clone prints correctly */
            .print-waveform-clone {
                display: block !important;
                position: absolute !important;
                z-index: 1000 !important;
                pointer-events: none !important;
            }

            .cell-waveform-window {
                position: relative !important;
                width: 100% !important;
                height: 100% !important;
                overflow: hidden !important;
            }

            /* Hide original waveform during print */
            body>.waveform-container {
                display: none !important;
            }
            
            .drawing-layer-container {
                display: block !important;
                position: absolute !important;
                z-index: 1000 !important;
            }

            .drawing-layer-container canvas {
                position: absolute !important;
            }
            /* â€”â€”â€” FIXÂ #1: keep drawing layer aligned on paper â€”â€”â€” */
            #printable-area {
                /* establish a containing block for absolute children on print */
                position: relative !important;
            }

            .drawing-layer-container {
                /* fill the sheet instead of using the screenâ€‘size snapshot */
                position: absolute !important;
                inset: 0 !important;      /* shorthand for top/right/bottom/left:0 */
                width: 100% !important;   /* follow any printâ€‘time scaling */
                height: 100% !important;
            }
            /* â€”â€”â€” FIXÂ #6: keep UI bars clickable while drawing â€”â€”â€” */
            .controls,
            .drawing-toolbar {
                position: relative;   /* establish new stacking context */
                z-index: 2000;        /* higher than the canvases (5) */
            }
            /* â€”â€”â€” FIXÂ #7: canvases are inert by default â€”â€”â€” */
            .drawing-layer canvas {
                pointer-events: none;
            }
        }
    </style>
</head>

<body>
    <div class="controls">
        <div>
            <label for="template-selector">Template:</label>
            <select id="template-selector">
                <option value="large">11"x17" (96 Frames)</option>
                <option value="small">8"x10" (48 Frames)</option>
            </select>
        </div>

        <div id="frame-count-container">
            <label for="frame-count">Frames:</label>
            <input type="number" id="frame-count" min="24" step="8" value="96">
        </div>

        <button id="audio-button">Import Audio</button>
        <input type="file" id="audio-upload" accept="audio/*">

        <button id="save-button">Save Project</button>
        <button id="load-button">Load Project</button>
        <button id="pdf-button">Export PDF</button>
        <button id="print-button">Print</button>
        <button id="add-rows-button">Add 8 Rows</button>
        <button id="clear-button">Clear All</button>
    </div>

    <div id="audio-controls">
        <button id="play-audio">Play/Pause</button>
        <button id="stop-audio">Stop</button>
        <input type="range" id="audio-scrubber" min="0" max="100" value="0" style="width: 200px;">
        <span id="audio-info">No audio loaded</span>
        <button id="add-phonetic">Add Phonetic Marker</button>
        <div style="margin-left: 10px; color: #666; font-style: italic;">
            âœ¨ TIP: Drag down the waveform column while holding the left mouse button to scrub audio frame-by-frame<br>
            ðŸ’¡ TIP: Click and drag to select multiple cells (use Ctrl+C to copy, Delete to clear)
        </div>
    </div>

    <div id="phonetic-input">
        <input type="text" id="phonetic-text" placeholder="Enter phonetic sound">
        <button id="save-phonetic">Save</button>
        <button id="cancel-phonetic">Cancel</button>
    </div>

    <div id="printable-area">
        <div class="header">
            <div class="title">3D ANIMATION X-SHEET</div>
        </div>

        <div class="metadata">
            <div><span>Project #:</span><input type="text" id="project-number"></div>
            <div><span>DATE:</span><input type="date" id="project-date"></div>
            <div><span>PAGE #:</span><input type="text" id="page-number"></div>
            <div><span>ANIMATOR:</span><input type="text" id="animator-name"></div>
            <div><span>VERSION:</span><input type="text" id="version-number"></div>
            <div><span>Shot #:</span><input type="text" id="shot-number"></div>
        </div>

        <table id="xsheet-table">
            <thead>
                <tr>
                    <th class="action-col">Action/Description</th>
                    <th class="frame-col">Fr</th>
                    <th class="waveform-col">Audio Waveform</th>
                    <th class="dialogue-col">Dialogue</th>
                    <th class="sound-col">Sound FX</th>
                    <th class="technical-col">Tech. Notes</th>
                    <th class="extra1-col">Extra 1</th>
                    <th class="extra2-col">Extra 2</th>
                    <th class="frame-col">Fr</th>
                    <th class="camera-col">Camera Moves</th>
                </tr>
            </thead>
            <tbody id="xsheet-body">
                <!-- Rows will be generated via JavaScript -->
            </tbody>
        </table>

        <div class="footer">
            Bold lines mark 8-frame intervals. Double lines mark 24-frame intervals (24fps).
            Left columns track character actions, middle columns for technical notes, right for camera moves.
        </div>
    </div>

    <div class="status" id="status-message"></div>

    <script>
        /**
         * INTERACTIVE X-SHEET DRAWING TOOLS IMPLEMENTATION
         *
         * This code adds comprehensive drawing capabilities to the animation X-Sheet.
         * Features include:
         * - Multiple drawing layers
         * - Various drawing tools (pen, line, arrows, shapes, text, images, animation symbols)
         * - Grid-aware annotation that can span multiple frames
         * - Object selection and manipulation
         * - Integration with saving, loading, and printing
         */
        
        /**
         * DRAWING LAYER SYSTEM
         * Manages the canvas layers that contain drawing objects
         */
        class DrawingLayerSystem {
            constructor(xsheetTable) {
                this.xsheetTable = xsheetTable;
                this.layers = [];
                this.activeLayerIndex = 0;
                this.container = null;
                
                this.init();
            }
            
            init() {
                // Create container aligned with table
                const printableArea = document.getElementById('printable-area');
                const tableRect = this.xsheetTable.getBoundingClientRect();
                this.container = document.createElement('div');
                this.container.className = 'drawing-layer-container';
                this.container.style.position = 'absolute';   // relative to printable-area
                this.container.style.inset = '0';          // top/right/bottom/left = 0
                this.container.style.width = '100%';
                this.container.style.height = '100%';
                this.container.style.pointerEvents = 'none';
                this.container.style.zIndex = '5';
                
                printableArea.appendChild(this.container);   // keep overlay inside the sheet
                
                // Create default background and foreground layers
                this.addLayer('background');
                this.addLayer('foreground');
                this.setActiveLayer(1); // Set foreground as active by default
                
                // Handle window resize and table changes
                this.setupResizeHandling();
            }
            
            addLayer(name) {
                const canvas = document.createElement('canvas');
                canvas.className = `drawing-layer-${name}`;
                canvas.width = this.container.clientWidth;
                canvas.height = this.container.clientHeight;
                canvas.style.position = 'absolute';
                canvas.style.left = '0';
                canvas.style.top = '0';
                canvas.style.pointerEvents = 'none';
                
                this.container.appendChild(canvas);
                
                const layer = {
                    name: name,
                    canvas: canvas,
                    context: canvas.getContext('2d'),
                    objects: [],
                    visible: true
                };
                
                this.layers.push(layer);
                return this.layers.length - 1; // Return index of new layer
            }
            
            setActiveLayer(index) {
                if (index >= 0 && index < this.layers.length) {
                    this.activeLayerIndex = index;
                    return true;
                }
                return false;
            }
            
            getActiveLayer() {
                return this.layers[this.activeLayerIndex];
            }
            
            setupResizeHandling() {
                // Update canvas position and size when window resizes
                window.addEventListener('resize', () => this.updateLayoutSize());
                
                // Custom event for when X-Sheet table changes
                document.addEventListener('xsheet-updated', () => this.updateLayoutSize());
            }
            
            updateLayoutSize() {
                const tableRect = this.xsheetTable.getBoundingClientRect();
                
                // Store current drawings from each layer
                const tempCanvases = this.layers.map(layer => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = layer.canvas.width;
                    tempCanvas.height = layer.canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(layer.canvas, 0, 0);
                    return tempCanvas;
                });
                
                // Update container position and dimensions
                this.container.style.left = '0';
                this.container.style.top = '0';
                this.container.style.width = `${tableRect.width}px`;
                this.container.style.height = `${tableRect.height}px`;
                
                // Update each layer canvas
                this.layers.forEach((layer, i) => {
                    const scaleX = tableRect.width / layer.canvas.width;
                    const scaleY = tableRect.height / layer.canvas.height;
                    
                    layer.canvas.width = tableRect.width;
                    layer.canvas.height = tableRect.height;
                    
                    // Redraw with scaling
                    layer.context.save();
                    layer.context.scale(scaleX, scaleY);
                    layer.context.drawImage(tempCanvases[i], 0, 0);
                    layer.context.restore();
                });
                
                // Force redraw of all objects
                this.redrawAll();
            }
            
            enableDrawing() {
                this.layers.forEach(layer => {
                    layer.canvas.style.pointerEvents = 'auto';
                });
            }
            
            disableDrawing() {
                this.layers.forEach(layer => {
                    layer.canvas.style.pointerEvents = 'none';
                });
            }
            
            clearLayer(layerIndex) {
                if (layerIndex >= 0 && layerIndex < this.layers.length) {
                    const layer = this.layers[layerIndex];
                    layer.context.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
                    layer.objects = [];
                }
            }
            
            clearAllLayers() {
                this.layers.forEach((layer, index) => {
                    this.clearLayer(index);
                });
            }
            
            // Convert screen coordinates to canvas coordinates
            screenToCanvas(screenX, screenY) {
                const containerRect = this.container.getBoundingClientRect();
                return {
                    x: screenX - containerRect.left,
                    y: screenY - containerRect.top
                };
            }
            
            // Convert frame/column to canvas coordinates (for multi-frame spanning)
            gridToCanvas(frame, column) {
                const cell = document.querySelector(`tr.frame-${frame} td:nth-child(${column})`);
                if (!cell) return null;
                
                const cellRect = cell.getBoundingClientRect();
                const containerRect = this.container.getBoundingClientRect();
                
                return {
                    x: cellRect.left - containerRect.left + cellRect.width / 2,
                    y: cellRect.top - containerRect.top + cellRect.height / 2
                };
            }
            
            // Add a drawing object to the active layer
            addObject(object) {
                const layer = this.getActiveLayer();
                layer.objects.push(object);
                this.redrawLayer(this.activeLayerIndex);
                return object;
            }
            
            // Redraw a specific layer
            redrawLayer(layerIndex) {
                if (layerIndex >= 0 && layerIndex < this.layers.length) {
                    const layer = this.layers[layerIndex];
                    layer.context.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
                    
                    // Draw all objects in this layer
                    layer.objects.forEach(obj => {
                        if (obj.visible) {
                            obj.draw(layer.context);
                        }
                    });
                }
            }
            
            // Redraw all layers
            redrawAll() {
                this.layers.forEach((_, index) => {
                    this.redrawLayer(index);
                });
            }
            
            // Find object under point
            findObjectAt(x, y) {
                // Check active layer first, then others in reverse order (top to bottom)
                const activeLayer = this.getActiveLayer();
                
                // Check active layer
                for (let i = activeLayer.objects.length - 1; i >= 0; i--) {
                    const obj = activeLayer.objects[i];
                    if (obj.containsPoint(x, y)) {
                        return { object: obj, layerIndex: this.activeLayerIndex };
                    }
                }
                
                // Check other layers from top to bottom
                for (let l = this.layers.length - 1; l >= 0; l--) {
                    if (l === this.activeLayerIndex) continue; // Skip active layer (already checked)
                    
                    const layer = this.layers[l];
                    if (!layer.visible) continue;
                    
                    for (let i = layer.objects.length - 1; i >= 0; i--) {
                        const obj = layer.objects[i];
                        if (obj.containsPoint(x, y)) {
                            return { object: obj, layerIndex: l };
                        }
                    }
                }
                
                return null;
            }
            
            // Remove object
            removeObject(object, layerIndex) {
                const layer = layerIndex !== undefined ? this.layers[layerIndex] : this.getActiveLayer();
                const index = layer.objects.indexOf(object);
                if (index !== -1) {
                    layer.objects.splice(index, 1);
                    this.redrawLayer(layerIndex !== undefined ? layerIndex : this.activeLayerIndex);
                    return true;
                }
                return false;
            }
        }
        
        /**
         * DRAWING OBJECT MODEL
         * Defines the object classes for different types of drawings
         */
        
        // Base class for all drawing objects
        class DrawingObject {
            constructor(props = {}) {
                this.x = props.x || 0;
                this.y = props.y || 0;
                this.color = props.color || '#000000';
                this.lineWidth = props.lineWidth || 2;
                this.visible = props.visible !== undefined ? props.visible : true;
                this.selected = false;
                this.type = 'drawingObject'; // Base type
            }
            
            draw(context) {
                // Base drawing functionality
                if (this.selected) {
                    this.drawSelectionMarkers(context);
                }
            }
            
            drawSelectionMarkers(context) {
                // Draw selection handles (default implementation)
                context.save();
                context.strokeStyle = '#0099ff';
                context.lineWidth = 1;
                context.setLineDash([5, 3]);
                
                // Default is to draw a box around the object
                // This should be overridden by subclasses with specific bounds
                const bounds = this.getBounds();
                context.strokeRect(
                    bounds.x - 2,
                    bounds.y - 2,
                    bounds.width + 4,
                    bounds.height + 4
                );
                
                context.restore();
            }
            
            getBounds() {
                // Default implementation - should be overridden
                return { x: this.x, y: this.y, width: 0, height: 0 };
            }
            
            containsPoint(x, y) {
                // Default implementation - should be overridden
                return false;
            }
            
            move(dx, dy) {
                this.x += dx;
                this.y += dy;
            }
            
            toJSON() {
                return {
                    type: this.type,
                    x: this.x,
                    y: this.y,
                    color: this.color,
                    lineWidth: this.lineWidth,
                    visible: this.visible
                };
            }
            
            static fromJSON(data) {
                // Factory method to create objects from JSON
                // This will be overridden by subclasses
                return new DrawingObject(data);
            }
        }
        
        // Line object
        class LineObject extends DrawingObject {
            constructor(props = {}) {
                super(props);
                this.x2 = props.x2 || 0;
                this.y2 = props.y2 || 0;
                this.type = 'line';
                this.dashPattern = props.dashPattern || [];
            }
            
            draw(context) {
                context.save();
                context.beginPath();
                context.strokeStyle = this.color;
                context.lineWidth = this.lineWidth;
                
                if (this.dashPattern.length > 0) {
                    context.setLineDash(this.dashPattern);
                }
                
                context.moveTo(this.x, this.y);
                context.lineTo(this.x2, this.y2);
                context.stroke();
                context.restore();
                
                super.draw(context);
            }
            
            getBounds() {
                const minX = Math.min(this.x, this.x2);
                const minY = Math.min(this.y, this.y2);
                const width = Math.abs(this.x2 - this.x);
                const height = Math.abs(this.y2 - this.y);
                
                return { x: minX, y: minY, width, height };
            }
            
            containsPoint(x, y) {
                // Check if point is near the line
                const lineLength = Math.sqrt(
                    Math.pow(this.x2 - this.x, 2) + Math.pow(this.y2 - this.y, 2)
                );
                
                // If line is too short, use a minimum distance
                if (lineLength < 1) {
                    const dx = x - this.x;
                    const dy = y - this.y;
                    return Math.sqrt(dx * dx + dy * dy) <= 5;
                }
                
                // Calculate distance from point to line segment
                const t = ((x - this.x) * (this.x2 - this.x) + (y - this.y) * (this.y2 - this.y)) / (lineLength * lineLength);
                
                if (t < 0) {
                    // Point is beyond start point
                    const dx = x - this.x;
                    const dy = y - this.y;
                    return Math.sqrt(dx * dx + dy * dy) <= 5;
                }
                
                if (t > 1) {
                    // Point is beyond end point
                    const dx = x - this.x2;
                    const dy = y - this.y2;
                    return Math.sqrt(dx * dx + dy * dy) <= 5;
                }
                
                // Calculate perpendicular distance
                const px = this.x + t * (this.x2 - this.x);
                const py = this.y + t * (this.y2 - this.y);
                const dx = x - px;
                const dy = y - py;
                return Math.sqrt(dx * dx + dy * dy) <= 5;
            }
            
            move(dx, dy) {
                super.move(dx, dy);
                this.x2 += dx;
                this.y2 += dy;
            }
            
            toJSON() {
                const json = super.toJSON();
                return {
                    ...json,
                    x2: this.x2,
                    y2: this.y2,
                    dashPattern: this.dashPattern
                };
            }
            
            static fromJSON(data) {
                return new LineObject(data);
            }
        }
        
        // Arrow object (extends Line)
        class ArrowObject extends LineObject {
            constructor(props = {}) {
                super(props);
                this.arrowSize = props.arrowSize || 10;
                this.type = 'arrow';
            }
            
            draw(context) {
                // Draw the line part
                super.draw(context);
                
                // Draw the arrowhead
                const angle = Math.atan2(this.y2 - this.y, this.x2 - this.x);
                context.save();
                context.fillStyle = this.color;
                context.beginPath();
                context.moveTo(this.x2, this.y2);
                context.lineTo(
                    this.x2 - this.arrowSize * Math.cos(angle - Math.PI/6),
                    this.y2 - this.arrowSize * Math.sin(angle - Math.PI/6)
                );
                context.lineTo(
                    this.x2 - this.arrowSize * Math.cos(angle + Math.PI/6),
                    this.y2 - this.arrowSize * Math.sin(angle + Math.PI/6)
                );
                context.closePath();
                context.fill();
                context.restore();
            }
            
            toJSON() {
                const json = super.toJSON();
                return {
                    ...json,
                    arrowSize: this.arrowSize
                };
            }
            
            static fromJSON(data) {
                return new ArrowObject(data);
            }
        }
        
        // Rectangle object
        class RectangleObject extends DrawingObject {
            constructor(props = {}) {
                super(props);
                this.width = props.width || 0;
                this.height = props.height || 0;
                this.fill = props.fill || false;
                this.fillColor = props.fillColor || this.color;
                this.type = 'rectangle';
            }
            
            draw(context) {
                context.save();
                context.strokeStyle = this.color;
                context.lineWidth = this.lineWidth;
                
                // Draw rectangle
                if (this.fill) {
                    context.fillStyle = this.fillColor;
                    context.fillRect(this.x, this.y, this.width, this.height);
                }
                context.strokeRect(this.x, this.y, this.width, this.height);
                context.restore();
                
                super.draw(context);
            }
            
            getBounds() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
            
            containsPoint(x, y) {
                // Check if point is inside or near the edge of the rectangle
                if (this.fill) {
                    // For filled rectangles, check if point is inside
                    return (
                        x >= this.x && x <= this.x + this.width &&
                        y >= this.y && y <= this.y + this.height
                    );
                } else {
                    // For unfilled rectangles, check if point is near the edges
                    const nearLeft = Math.abs(x - this.x) <= 5;
                    const nearRight = Math.abs(x - (this.x + this.width)) <= 5;
                    const nearTop = Math.abs(y - this.y) <= 5;
                    const nearBottom = Math.abs(y - (this.y + this.height)) <= 5;
                    
                    return (
                        (nearLeft || nearRight) && (y >= this.y && y <= this.y + this.height) ||
                        (nearTop || nearBottom) && (x >= this.x && x <= this.x + this.width)
                    );
                }
            }
            
            toJSON() {
                const json = super.toJSON();
                return {
                    ...json,
                    width: this.width,
                    height: this.height,
                    fill: this.fill,
                    fillColor: this.fillColor
                };
            }
            
            static fromJSON(data) {
                return new RectangleObject(data);
            }
        }
        
        // Circle/Ellipse object
        class EllipseObject extends DrawingObject {
            constructor(props = {}) {
                super(props);
                this.radiusX = props.radiusX || 0;
                this.radiusY = props.radiusY || 0;
                this.fill = props.fill || false;
                this.fillColor = props.fillColor || this.color;
                this.type = 'ellipse';
            }
            
            draw(context) {
                context.save();
                context.beginPath();
                context.strokeStyle = this.color;
                context.lineWidth = this.lineWidth;
                
                // Draw ellipse
                context.ellipse(
                    this.x,
                    this.y,
                    this.radiusX,
                    this.radiusY,
                    0,
                    0,
                    2 * Math.PI
                );
                
                if (this.fill) {
                    context.fillStyle = this.fillColor;
                    context.fill();
                }
                context.stroke();
                context.restore();
                
                super.draw(context);
            }
            
            getBounds() {
                return {
                    x: this.x - this.radiusX,
                    y: this.y - this.radiusY,
                    width: this.radiusX * 2,
                    height: this.radiusY * 2
                };
            }
            
            containsPoint(x, y) {
                // Check if point is inside or near the edge of the ellipse
                const normalizedX = (x - this.x) / this.radiusX;
                const normalizedY = (y - this.y) / this.radiusY;
                const distance = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
                
                if (this.fill) {
                    // For filled ellipses, check if point is inside
                    return distance <= 1.0;
                } else {
                    // For unfilled ellipses, check if point is near the edge
                    return Math.abs(distance - 1.0) <= 5 / this.radiusX;
                }
            }
            
            toJSON() {
                const json = super.toJSON();
                return {
                    ...json,
                    radiusX: this.radiusX,
                    radiusY: this.radiusY,
                    fill: this.fill,
                    fillColor: this.fillColor
                };
            }
            
            static fromJSON(data) {
                return new EllipseObject(data);
            }
        }
        
        // Text object
        class TextObject extends DrawingObject {
            constructor(props = {}) {
                super(props);
                this.text = props.text || '';
                this.fontSize = props.fontSize || 14;
                this.fontFamily = props.fontFamily || 'Arial, sans-serif';
                this.align = props.align || 'left';
                this.type = 'text';
            }
            
            draw(context) {
                context.save();
                context.fillStyle = this.color;
                context.font = `${this.fontSize}px ${this.fontFamily}`;
                context.textAlign = this.align;
                
                // Draw text
                context.fillText(this.text, this.x, this.y);
                context.restore();
                
                super.draw(context);
            }
            
            getBounds() {
                // Estimate text dimensions
                const dummyCanvas = document.createElement('canvas');
                const ctx = dummyCanvas.getContext('2d');
                ctx.font = `${this.fontSize}px ${this.fontFamily}`;
                const metrics = ctx.measureText(this.text);
                const height = this.fontSize; // Approximation
                
                return {
                    x: this.align === 'center' ? this.x - metrics.width / 2 :
                       this.align === 'right' ? this.x - metrics.width : this.x,
                    y: this.y - height,
                    width: metrics.width,
                    height: height
                };
            }
            
            containsPoint(x, y) {
                const bounds = this.getBounds();
                return (
                    x >= bounds.x && x <= bounds.x + bounds.width &&
                    y >= bounds.y && y <= bounds.y + bounds.height
                );
            }
            
            toJSON() {
                const json = super.toJSON();
                return {
                    ...json,
                    text: this.text,
                    fontSize: this.fontSize,
                    fontFamily: this.fontFamily,
                    align: this.align
                };
            }
            
            static fromJSON(data) {
                return new TextObject(data);
            }
        }
        
        // Image object
        class ImageObject extends DrawingObject {
            constructor(props = {}) {
                super(props);
                this.width = props.width || 0;
                this.height = props.height || 0;
                this.imageUrl = props.imageUrl || '';
                this.image = null;
                this.loaded = false;
                this.type = 'image';
                
                // Load the image if provided
                if (this.imageUrl) {
                    this.loadImage(this.imageUrl);
                }
            }
            
            loadImage(url) {
                this.image = new Image();
                this.image.onload = () => {
                    this.loaded = true;
                    
                    // If dimensions not specified, use image dimensions
                    if (this.width === 0 || this.height === 0) {
                        this.width = this.image.width;
                        this.height = this.image.height;
                    }
                    
                    // Trigger redraw
                    document.dispatchEvent(new Event('xsheet-redraw'));
                };
                this.image.src = url;
            }
            
            draw(context) {
                if (this.loaded && this.image) {
                    context.save();
                    context.drawImage(this.image, this.x, this.y, this.width, this.height);
                    context.restore();
                } else if (!this.loaded) {
                    // Draw placeholder while loading
                    context.save();
                    context.strokeStyle = '#999999';
                    context.lineWidth = 1;
                    context.strokeRect(this.x, this.y, this.width, this.height);
                    context.font = '10px Arial';
                    context.fillStyle = '#999999';
                    context.fillText('Loading Image...', this.x + 5, this.y + 15);
                    context.restore();
                }
                
                super.draw(context);
            }
            
            getBounds() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
            
            containsPoint(x, y) {
                return (
                    x >= this.x && x <= this.x + this.width &&
                    y >= this.y && y <= this.y + this.height
                );
            }
            
            toJSON() {
                const json = super.toJSON();
                return {
                    ...json,
                    width: this.width,
                    height: this.height,
                    imageUrl: this.imageUrl
                };
            }
            
            static fromJSON(data) {
                return new ImageObject(data);
            }
        }
        
        // Symbol object (predefined animation symbols)
        class SymbolObject extends DrawingObject {
            constructor(props = {}) {
                super(props);
                this.symbolType = props.symbolType || 'default';
                this.scale = props.scale || 1.0;
                this.type = 'symbol';
            }
            
            draw(context) {
                context.save();
                context.strokeStyle = this.color;
                context.fillStyle = this.color;
                context.lineWidth = this.lineWidth;
                
                // Draw based on symbol type
                switch (this.symbolType) {
                    case 'anticipation':
                        this.drawAnticipation(context);
                        break;
                    case 'impact':
                        this.drawImpact(context);
                        break;
                    case 'keyframe':
                        this.drawKeyframe(context);
                        break;
                    case 'inbetween':
                        this.drawInbetween(context);
                        break;
                    case 'hold':
                        this.drawHold(context);
                        break;
                    default:
                        this.drawDefault(context);
                }
                
                context.restore();
                super.draw(context);
            }
            
            drawAnticipation(context) {
                context.save();
                context.translate(this.x, this.y);
                context.scale(this.scale, this.scale);
                
                // Draw curved arrow going back
                context.beginPath();
                context.moveTo(0, 0);
                context.bezierCurveTo(-20, -5, -25, 10, -10, 15);
                context.stroke();
                
                // Draw arrowhead
                context.beginPath();
                context.moveTo(-10, 15);
                context.lineTo(-5, 10);
                context.lineTo(-15, 5);
                context.closePath();
                context.fill();
                
                context.restore();
            }
            
            drawImpact(context) {
                context.save();
                context.translate(this.x, this.y);
                context.scale(this.scale, this.scale);
                
                // Draw impact star
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const innerRadius = 5;
                    const outerRadius = 15;
                    
                    context.beginPath();
                    context.moveTo(
                        innerRadius * Math.cos(angle),
                        innerRadius * Math.sin(angle)
                    );
                    context.lineTo(
                        outerRadius * Math.cos(angle),
                        outerRadius * Math.sin(angle)
                    );
                    context.stroke();
                }
                
                context.restore();
            }
            
            drawKeyframe(context) {
                context.save();
                context.translate(this.x, this.y);
                context.scale(this.scale, this.scale);
                
                // Draw diamond
                context.beginPath();
                context.moveTo(0, -10);
                context.lineTo(10, 0);
                context.lineTo(0, 10);
                context.lineTo(-10, 0);
                context.closePath();
                context.stroke();
                context.fill();
                
                context.restore();
            }
            
            drawInbetween(context) {
                context.save();
                context.translate(this.x, this.y);
                context.scale(this.scale, this.scale);
                
                // Draw circle
                context.beginPath();
                context.arc(0, 0, 7, 0, Math.PI * 2);
                context.stroke();
                
                context.restore();
            }
            
            drawHold(context) {
                context.save();
                context.translate(this.x, this.y);
                context.scale(this.scale, this.scale);
                
                // Draw horizontal bar
                context.beginPath();
                context.moveTo(-15, 0);
                context.lineTo(15, 0);
                context.lineWidth = this.lineWidth * 2;
                context.stroke();
                
                context.restore();
            }
            
            drawDefault(context) {
                context.save();
                context.translate(this.x, this.y);
                context.scale(this.scale, this.scale);
                
                // Draw square
                context.beginPath();
                context.rect(-7, -7, 14, 14);
                context.stroke();
                
                context.restore();
            }
            
            getBounds() {
                // Approximate bounds based on symbol type
                const size = 20 * this.scale;
                return {
                    x: this.x - size / 2,
                    y: this.y - size / 2,
                    width: size,
                    height: size
                };
            }
            
            containsPoint(x, y) {
                const bounds = this.getBounds();
                const dx = x - this.x;
                const dy = y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Use a radius-based check as most symbols are roughly circular
                return distance <= bounds.width / 2;
            }
            
            toJSON() {
                const json = super.toJSON();
                return {
                    ...json,
                    symbolType: this.symbolType,
                    scale: this.scale
                };
            }
            
            static fromJSON(data) {
                return new SymbolObject(data);
            }
        }
        
        // Free-form path (for pen/brush tools)
        class PathObject extends DrawingObject {
            constructor(props = {}) {
                super(props);
                this.points = props.points || [];
                this.smoothing = props.smoothing !== undefined ? props.smoothing : true;
                this.closed = props.closed || false;
                this.fill = props.fill || false;
                this.fillColor = props.fillColor || this.color;
                this.type = 'path';
            }
            
            addPoint(x, y) {
                this.points.push({ x, y });
            }
            
            draw(context) {
                if (this.points.length < 2) return;
                
                context.save();
                context.beginPath();
                context.strokeStyle = this.color;
                context.lineWidth = this.lineWidth;
                context.lineJoin = 'round';
                context.lineCap = 'round';
                
                // Start from first point
                context.moveTo(this.points[0].x, this.points[0].y);
                
                if (this.smoothing && this.points.length > 2) {
                    // Draw using bezier curves for smoothing
                    for (let i = 1; i < this.points.length - 1; i++) {
                        const p1 = this.points[i];
                        const p2 = this.points[i + 1];
                        
                        const xc = (p1.x + p2.x) / 2;
                        const yc = (p1.y + p2.y) / 2;
                        
                        context.quadraticCurveTo(p1.x, p1.y, xc, yc);
                    }
                    
                    // Connect to the last point
                    const last = this.points[this.points.length - 1];
                    context.lineTo(last.x, last.y);
                } else {
                    // Simple line segments
                    for (let i = 1; i < this.points.length; i++) {
                        context.lineTo(this.points[i].x, this.points[i].y);
                    }
                }
                
                if (this.closed) {
                    context.closePath();
                }
                
                if (this.fill) {
                    context.fillStyle = this.fillColor;
                    context.fill();
                }
                
                context.stroke();
                context.restore();
                
                super.draw(context);
            }
            
            getBounds() {
                if (this.points.length === 0) {
                    return { x: this.x, y: this.y, width: 0, height: 0 };
                }
                
                let minX = this.points[0].x;
                let maxX = this.points[0].x;
                let minY = this.points[0].y;
                let maxY = this.points[0].y;
                
                // Find min/max coordinates
                for (let i = 1; i < this.points.length; i++) {
                    const point = this.points[i];
                    minX = Math.min(minX, point.x);
                    maxX = Math.max(maxX, point.x);
                    minY = Math.min(minY, point.y);
                    maxY = Math.max(maxY, point.y);
                }
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }
            
            containsPoint(x, y) {
                if (this.points.length < 2) return false;
                
                // Check if point is near any line segment
                for (let i = 0; i < this.points.length - 1; i++) {
                    const p1 = this.points[i];
                    const p2 = this.points[i + 1];
                    
                    const lineLength = Math.sqrt(
                        Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)
                    );
                    
                    // If line is too short, check distance to point
                    if (lineLength < 1) {
                        const dx = x - p1.x;
                        const dy = y - p1.y;
                        if (Math.sqrt(dx * dx + dy * dy) <= 5) {
                            return true;
                        }
                        continue;
                    }
                    
                    // Calculate distance from point to line segment
                    const t = ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / (lineLength * lineLength);
                    
                    if (t < 0) {
                        // Point is beyond start point
                        const dx = x - p1.x;
                        const dy = y - p1.y;
                        if (Math.sqrt(dx * dx + dy * dy) <= 5) {
                            return true;
                        }
                    } else if (t > 1) {
                        // Point is beyond end point
                        const dx = x - p2.x;
                        const dy = y - p2.y;
                        if (Math.sqrt(dx * dx + dy * dy) <= 5) {
                            return true;
                        }
                    } else {
                        // Calculate perpendicular distance
                        const px = p1.x + t * (p2.x - p1.x);
                        const py = p1.y + t * (p2.y - p1.y);
                        const dx = x - px;
                        const dy = y - py;
                        if (Math.sqrt(dx * dx + dy * dy) <= 5) {
                            return true;
                        }
                    }
                }
                
                // If closed and filled, also check if point is inside
                if (this.closed && this.fill) {
                    // Use point-in-polygon algorithm
                    let inside = false;
                    for (let i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {
                        const xi = this.points[i].x;
                        const yi = this.points[i].y;
                        const xj = this.points[j].x;
                        const yj = this.points[j].y;
                        
                        const intersect = ((yi > y) !== (yj > y)) &&
                            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                            
                        if (intersect) inside = !inside;
                    }
                    return inside;
                }
                
                return false;
            }
            
            move(dx, dy) {
                super.move(dx, dy);
                
                // Move all points
                this.points.forEach(point => {
                    point.x += dx;
                    point.y += dy;
                });
            }
            
            toJSON() {
                const json = super.toJSON();
                return {
                    ...json,
                    points: this.points,
                    smoothing: this.smoothing,
                    closed: this.closed,
                    fill: this.fill,
                    fillColor: this.fillColor
                };
            }
            
            static fromJSON(data) {
                return new PathObject(data);
            }
        }
        
        // Frame-Spanning Line (connects specific cells in the grid)
        class FrameSpanningLineObject extends DrawingObject {
            constructor(props = {}) {
                super(props);
                this.startFrame = props.startFrame || 1;
                this.startColumn = props.startColumn || 1;
                this.endFrame = props.endFrame || 1;
                this.endColumn = props.endColumn || 1;
                this.type = 'frameSpanningLine';
                this.dashPattern = props.dashPattern || [];
                this.arrowStart = props.arrowStart || false;
                this.arrowEnd = props.arrowEnd || false;
                this.arrowSize = props.arrowSize || 10;
            }
            
            draw(context) {
                // Calculate actual coordinates from frame and column
                const layerSystem = window.xsheetDrawing.layerSystem;
                
                const startPos = layerSystem.gridToCanvas(this.startFrame, this.startColumn);
                const endPos = layerSystem.gridToCanvas(this.endFrame, this.endColumn);
                
                if (!startPos || !endPos) return; // Skip if cells not found
                
                context.save();
                context.beginPath();
                context.strokeStyle = this.color;
                context.lineWidth = this.lineWidth;
                
                if (this.dashPattern.length > 0) {
                    context.setLineDash(this.dashPattern);
                }
                
                context.moveTo(startPos.x, startPos.y);
                context.lineTo(endPos.x, endPos.y);
                context.stroke();
                
                // Draw arrows if needed
                if (this.arrowStart) {
                    this.drawArrow(context, endPos.x, endPos.y, startPos.x, startPos.y);
                }
                
                if (this.arrowEnd) {
                    this.drawArrow(context, startPos.x, startPos.y, endPos.x, endPos.y);
                }
                
                context.restore();
                
                // Store computed coordinates for selection/hit testing
                this.computedStart = startPos;
                this.computedEnd = endPos;
                
                super.draw(context);
            }
            
            drawArrow(context, fromX, fromY, toX, toY) {
                const angle = Math.atan2(toY - fromY, toX - fromX);
                
                context.save();
                context.fillStyle = this.color;
                context.beginPath();
                context.moveTo(toX, toY);
                context.lineTo(
                    toX - this.arrowSize * Math.cos(angle - Math.PI/6),
                    toY - this.arrowSize * Math.sin(angle - Math.PI/6)
                );
                context.lineTo(
                    toX - this.arrowSize * Math.cos(angle + Math.PI/6),
                    toY - this.arrowSize * Math.sin(angle + Math.PI/6)
                );
                context.closePath();
                context.fill();
                context.restore();
            }
            
            getBounds() {
                if (!this.computedStart || !this.computedEnd) return { x: 0, y: 0, width: 0, height: 0 };
                
                const minX = Math.min(this.computedStart.x, this.computedEnd.x);
                const minY = Math.min(this.computedStart.y, this.computedEnd.y);
                const width = Math.abs(this.computedEnd.x - this.computedStart.x);
                const height = Math.abs(this.computedEnd.y - this.computedStart.y);
                
                return { x: minX, y: minY, width, height };
            }
            
            containsPoint(x, y) {
                if (!this.computedStart || !this.computedEnd) return false;
                
                // Same algorithm as LineObject
                const lineLength = Math.sqrt(
                    Math.pow(this.computedEnd.x - this.computedStart.x, 2) +
                    Math.pow(this.computedEnd.y - this.computedStart.y, 2)
                );
                
                if (lineLength < 1) {
                    const dx = x - this.computedStart.x;
                    const dy = y - this.computedStart.y;
                    return Math.sqrt(dx * dx + dy * dy) <= 5;
                }
                
                const t = ((x - this.computedStart.x) * (this.computedEnd.x - this.computedStart.x) +
                          (y - this.computedStart.y) * (this.computedEnd.y - this.computedStart.y)) /
                         (lineLength * lineLength);
                
                if (t < 0) {
                    const dx = x - this.computedStart.x;
                    const dy = y - this.computedStart.y;
                    return Math.sqrt(dx * dx + dy * dy) <= 5;
                }
                
                if (t > 1) {
                    const dx = x - this.computedEnd.x;
                    const dy = y - this.computedEnd.y;
                    return Math.sqrt(dx * dx + dy * dy) <= 5;
                }
                
                const px = this.computedStart.x + t * (this.computedEnd.x - this.computedStart.x);
                const py = this.computedStart.y + t * (this.computedEnd.y - this.computedStart.y);
                const dx = x - px;
                const dy = y - py;
                return Math.sqrt(dx * dx + dy * dy) <= 5;
            }
            
            // This object type doesn't use the regular move method
            // Instead, it updates the frame/column values
            
            toJSON() {
                const json = super.toJSON();
                return {
                    ...json,
                    startFrame: this.startFrame,
                    startColumn: this.startColumn,
                    endFrame: this.endFrame,
                    endColumn: this.endColumn,
                    dashPattern: this.dashPattern,
                    arrowStart: this.arrowStart,
                    arrowEnd: this.arrowEnd,
                    arrowSize: this.arrowSize
                };
            }
            
            static fromJSON(data) {
                return new FrameSpanningLineObject(data);
            }
        }
        
        // Register all object types in a factory
        const DrawingObjectFactory = {
            types: {
                'drawingObject': DrawingObject,
                'line': LineObject,
                'arrow': ArrowObject,
                'rectangle': RectangleObject,
                'ellipse': EllipseObject,
                'text': TextObject,
                'image': ImageObject,
                'symbol': SymbolObject,
                'path': PathObject,
                'frameSpanningLine': FrameSpanningLineObject
            },
            
            createFromJSON(data) {
                const Type = this.types[data.type];
                if (Type) {
                    return Type.fromJSON(data);
                }
                return null;
            }
        };
        
        /**
         * DRAWING TOOL SYSTEM
         * Manages the drawing tools and interfaces with the layer system
         */
        class DrawingToolSystem {
            constructor(layerSystem) {
                this.layerSystem = layerSystem;
                this.activeTool = null;
                this.toolSettings = {
                    color: '#ff0000',
                    lineWidth: 2,
                    fill: false,
                    fillColor: '#ff8080',
                    fontSize: 16,
                    fontFamily: 'Arial, sans-serif',
                    textAlign: 'left',
                    symbolType: 'default',
                    symbolScale: 1.0
                };
                
                this.availableTools = {
                    'select': new SelectTool(this),
                    'pen': new PenTool(this),
                    'line': new LineTool(this),
                    'arrow': new ArrowTool(this),
                    'rectangle': new RectangleTool(this),
                    'ellipse': new EllipseTool(this),
                    'text': new TextTool(this),
                    'image': new ImageTool(this),
                    'symbol': new SymbolTool(this),
                    'frameLine': new FrameSpanningLineTool(this),
                    'eraser': new EraserTool(this)
                };
                
                // Default to select tool
                this.setActiveTool('select');
                
                // Set up toolbar UI
                this.createToolbar();
            }
            
            setActiveTool(toolName) {
                if (this.activeTool) {
                    this.activeTool.deactivate();
                }
                
                if (this.availableTools[toolName]) {
                    this.activeTool = this.availableTools[toolName];
                    this.activeTool.activate();
                    return true;
                }
                
                return false;
            }
            
            createToolbar() {
                // Create toolbar container
                const toolbar = document.createElement('div');
                toolbar.className = 'drawing-toolbar';
                toolbar.style.display = 'flex';
                toolbar.style.flexWrap = 'wrap';
                toolbar.style.gap = '5px';
                toolbar.style.padding = '10px';
                toolbar.style.backgroundColor = '#f5f5f5';
                toolbar.style.marginBottom = '10px';
                toolbar.style.borderRadius = '5px';
                
                // Add tool buttons
                this.addToolButton(toolbar, 'select', 'Select', 'ðŸ‘†');
                this.addToolButton(toolbar, 'pen', 'Freehand Drawing', 'âœï¸');
                this.addToolButton(toolbar, 'line', 'Line', 'â€”');
                this.addToolButton(toolbar, 'arrow', 'Arrow', 'â†’');
                this.addToolButton(toolbar, 'rectangle', 'Rectangle', 'â–¡');
                this.addToolButton(toolbar, 'ellipse', 'Circle/Ellipse', 'â—‹');
                this.addToolButton(toolbar, 'text', 'Text', 'T');
                this.addToolButton(toolbar, 'image', 'Insert Image', 'ðŸ–¼ï¸');
                this.addToolButton(toolbar, 'symbol', 'Animation Symbol', 'â­');
                this.addToolButton(toolbar, 'frameLine', 'Multi-Frame Line', 'â†•ï¸');
                
                // Add separator
                toolbar.appendChild(document.createElement('div')).style.borderLeft = '1px solid #ccc';
                toolbar.lastChild.style.height = '30px';
                
                // Add color picker
                const colorContainer = document.createElement('div');
                colorContainer.style.display = 'flex';
                colorContainer.style.alignItems = 'center';
                colorContainer.style.gap = '5px';
                
                const colorLabel = document.createElement('label');
                colorLabel.textContent = 'Color:';
                colorLabel.htmlFor = 'drawing-color';
                
                const colorPicker = document.createElement('input');
                colorPicker.type = 'color';
                colorPicker.id = 'drawing-color';
                colorPicker.value = this.toolSettings.color;
                colorPicker.addEventListener('input', (e) => {
                    this.toolSettings.color = e.target.value;
                });
                
                colorContainer.appendChild(colorLabel);
                colorContainer.appendChild(colorPicker);
                toolbar.appendChild(colorContainer);
                
                // Add line width selector
                const lineWidthContainer = document.createElement('div');
                lineWidthContainer.style.display = 'flex';
                lineWidthContainer.style.alignItems = 'center';
                lineWidthContainer.style.gap = '5px';
                
                const lineWidthLabel = document.createElement('label');
                lineWidthLabel.textContent = 'Width:';
                lineWidthLabel.htmlFor = 'drawing-line-width';
                
                const lineWidthSelect = document.createElement('select');
                lineWidthSelect.id = 'drawing-line-width';
                
                const widths = [1, 2, 3, 5, 8, 12];
                widths.forEach(width => {
                    const option = document.createElement('option');
                    option.value = width;
                    option.textContent = width + 'px';
                    if (width === this.toolSettings.lineWidth) {
                        option.selected = true;
                    }
                    lineWidthSelect.appendChild(option);
                });
                
                lineWidthSelect.addEventListener('change', (e) => {
                    this.toolSettings.lineWidth = parseInt(e.target.value);
                });
                
                lineWidthContainer.appendChild(lineWidthLabel);
                lineWidthContainer.appendChild(lineWidthSelect);
                toolbar.appendChild(lineWidthContainer);
                
                // Add fill option
                const fillContainer = document.createElement('div');
                fillContainer.style.display = 'flex';
                fillContainer.style.alignItems = 'center';
                fillContainer.style.gap = '5px';
                
                const fillCheck = document.createElement('input');
                fillCheck.type = 'checkbox';
                fillCheck.id = 'drawing-fill';
                fillCheck.checked = this.toolSettings.fill;
                
                const fillLabel = document.createElement('label');
                fillLabel.textContent = 'Fill';
                fillLabel.htmlFor = 'drawing-fill';
                
                fillCheck.addEventListener('change', (e) => {
                    this.toolSettings.fill = e.target.checked;
                    fillColorPicker.disabled = !e.target.checked;
                });
                
                const fillColorPicker = document.createElement('input');
                fillColorPicker.type = 'color';
                fillColorPicker.id = 'drawing-fill-color';
                fillColorPicker.value = this.toolSettings.fillColor;
                fillColorPicker.disabled = !this.toolSettings.fill;
                
                fillColorPicker.addEventListener('input', (e) => {
                    this.toolSettings.fillColor = e.target.value;
                });
                
                fillContainer.appendChild(fillCheck);
                fillContainer.appendChild(fillLabel);
                fillContainer.appendChild(fillColorPicker);
                toolbar.appendChild(fillContainer);
                
                // Add separator
                toolbar.appendChild(document.createElement('div')).style.borderLeft = '1px solid #ccc';
                toolbar.lastChild.style.height = '30px';
                
                // Add layer selector
                const layerSelector = document.createElement('select');
                layerSelector.id = 'drawing-layer-selector';
                
                // Add options for each layer
                this.layerSystem.layers.forEach((layer, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = layer.name;
                    if (index === this.layerSystem.activeLayerIndex) {
                        option.selected = true;
                    }
                    layerSelector.appendChild(option);
                });
                
                layerSelector.addEventListener('change', (e) => {
                    this.layerSystem.setActiveLayer(parseInt(e.target.value));
                });
                
                const layerLabel = document.createElement('label');
                layerLabel.textContent = 'Layer:';
                layerLabel.htmlFor = 'drawing-layer-selector';
                layerLabel.style.marginRight = '5px';
                
                toolbar.appendChild(layerLabel);
                toolbar.appendChild(layerSelector);
                
                // Add separator
                toolbar.appendChild(document.createElement('div')).style.borderLeft = '1px solid #ccc';
                toolbar.lastChild.style.height = '30px';
                
                // Add eraser tool
                this.addToolButton(toolbar, 'eraser', 'Eraser', 'ðŸ§¹');
                
                // Add clear button
                const clearButton = document.createElement('button');
                clearButton.textContent = 'Clear All Drawings';
                clearButton.style.backgroundColor = '#ff5555';
                clearButton.style.color = 'white';
                clearButton.style.border = 'none';
                clearButton.style.borderRadius = '4px';
                clearButton.style.padding = '5px 10px';
                clearButton.style.cursor = 'pointer';
                
                clearButton.addEventListener('click', () => {
                    if (confirm('Are you sure you want to clear all drawings?')) {
                        this.layerSystem.clearAllLayers();
                    }
                });
                
                toolbar.appendChild(clearButton);
                
                // Find controls div and add toolbar before it
                const controls = document.querySelector('.controls');
                if (controls) {
                    controls.parentNode.insertBefore(toolbar, controls.nextSibling);
                } else {
                    document.body.insertBefore(toolbar, document.body.firstChild);
                }
            }
            
            addToolButton(toolbar, toolName, tooltip, icon) {
                const button = document.createElement('button');
                button.textContent = icon;
                button.title = tooltip;
                button.style.width = '36px';
                button.style.height = '36px';
                button.style.fontSize = '16px';
                button.style.margin = '0';
                button.style.padding = '5px';
                button.style.borderRadius = '4px';
                button.style.border = '1px solid #ccc';
                button.style.backgroundColor = 'white';
                button.style.cursor = 'pointer';
                
                button.addEventListener('click', () => {
                    this.setActiveTool(toolName);
                    
                    // Update active button styling
                    document.querySelectorAll('.drawing-toolbar button').forEach(btn => {
                        btn.style.backgroundColor = 'white';
                        btn.style.color = 'black';
                    });
                    
                    button.style.backgroundColor = '#4CAF50';
                    button.style.color = 'white';
                });
                
                // Set active state for default tool
                if (toolName === 'select') {
                    button.style.backgroundColor = '#4CAF50';
                    button.style.color = 'white';
                }
                
                toolbar.appendChild(button);
            }
        }
        
        /**
         * DRAWING TOOLS
         * Individual tool implementations
         */
        
        // Base tool class
        class DrawingTool {
            constructor(toolSystem) {
                this.toolSystem = toolSystem;
                this.layerSystem = toolSystem.layerSystem;
                this.active = false;
                this.settings = toolSystem.toolSettings;
            }
            
            activate() {
                this.active = true;
                this.layerSystem.enableDrawing();
                this.attachEvents();
            }
            
            deactivate() {
                this.active = false;
                // turn pointer-events back off so clicks go to the table cells
                this.toolSystem.layerSystem.disableDrawing();
                this.detachEvents();
            }
            
            attachEvents() {
                // Override in subclasses
            }
            
            detachEvents() {
                // Override in subclasses
            }
        }
        
        // Select tool for manipulating objects
        class SelectTool extends DrawingTool {
            
            constructor(toolSystem) {
                super(toolSystem);
                this.selectedObject = null;
                this.selectedLayer = null;
                this.dragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.objectStart = { x: 0, y: 0 };
            }
            activate() {
                this.active = true;
                // let pointer-events go to the table cells instead of the canvases
                this.layerSystem.disableDrawing();
                this.attachEvents();
            }

            deactivate() {
                this.active = false;
                this.layerSystem.disableDrawing();
                this.detachEvents();
            }
            attachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.addEventListener('mousedown', this.handleMouseDown);
                canvas.addEventListener('pointerdown', this.handleMouseDown);
                document.addEventListener('mousemove', this.handleMouseMove);
                document.addEventListener('pointermove', this.handleMouseMove);
                document.addEventListener('mouseup', this.handleMouseUp);
                document.addEventListener('pointerup',   this.handleMouseUp);
                document.addEventListener('keydown', this.handleKeyDown);
            }
            
            detachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.removeEventListener('mousedown', this.handleMouseDown);
                canvas.removeEventListener('pointerdown', this.handleMouseDown);
                document.removeEventListener('mousemove', this.handleMouseMove);
                document.removeEventListener('pointermove', this.handleMouseMove);
                document.removeEventListener('mouseup', this.handleMouseUp);
                document.removeEventListener('pointerup',   this.handleMouseUp);
                document.removeEventListener('keydown', this.handleKeyDown);
                
                // Clear selection
                this.clearSelection();
            }
            
            handleMouseDown = (e) => {
                // Convert to canvas coordinates
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                // Check if clicked on an object
                const hit = this.layerSystem.findObjectAt(coords.x, coords.y);
                
                if (hit) {
                    // Select the object
                    this.selectObject(hit.object, hit.layerIndex);
                    
                    // Start drag
                    this.dragging = true;
                    this.dragStart = { x: coords.x, y: coords.y };
                    this.objectStart = { x: hit.object.x, y: hit.object.y };
                } else {
                    // Clear selection if clicked empty space
                    this.clearSelection();
                }
            }
            
            handleMouseMove = (e) => {
                if (!this.dragging || !this.selectedObject) return;
                
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                // Calculate move distance
                const dx = coords.x - this.dragStart.x;
                const dy = coords.y - this.dragStart.y;
                
                // Move the selected object
                this.selectedObject.x = this.objectStart.x + dx;
                this.selectedObject.y = this.objectStart.y + dy;
                
                // For objects with special move handling
                this.selectedObject.move(dx, dy);
                this.selectedObject.x = this.objectStart.x; // Reset x as move() already handled it
                this.selectedObject.y = this.objectStart.y; // Reset y as move() already handled it
                
                // Redraw
                this.layerSystem.redrawAll();
            }
            
            handleMouseUp = () => {
                this.dragging = false;
            }
            
            handleKeyDown = (e) => {
                if (!this.selectedObject) return;
                
                // Delete key
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    this.layerSystem.removeObject(this.selectedObject, this.selectedLayer);
                    this.clearSelection();
                }
                
                // Arrow keys for fine movement
                const moveDistance = e.shiftKey ? 10 : 1;
                
                if (e.key === 'ArrowLeft') {
                    this.selectedObject.move(-moveDistance, 0);
                    this.layerSystem.redrawAll();
                } else if (e.key === 'ArrowRight') {
                    this.selectedObject.move(moveDistance, 0);
                    this.layerSystem.redrawAll();
                } else if (e.key === 'ArrowUp') {
                    this.selectedObject.move(0, -moveDistance);
                    this.layerSystem.redrawAll();
                } else if (e.key === 'ArrowDown') {
                    this.selectedObject.move(0, moveDistance);
                    this.layerSystem.redrawAll();
                }
            }
            
            selectObject(object, layerIndex) {
                // Clear previous selection
                this.clearSelection();
                
                // Set new selection
                this.selectedObject = object;
                this.selectedLayer = layerIndex;
                object.selected = true;
                
                // Redraw with selection visual
                this.layerSystem.redrawAll();
            }
            
            clearSelection() {
                if (this.selectedObject) {
                    this.selectedObject.selected = false;
                    this.selectedObject = null;
                    this.selectedLayer = null;
                    this.layerSystem.redrawAll();
                }
            }
        }
        
        // Pen tool for free drawing
        class PenTool extends DrawingTool {
            constructor(toolSystem) {
                super(toolSystem);
                this.currentPath = null;
                this.drawing = false;
            }
            
            attachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.addEventListener('mousedown', this.handleMouseDown);
                canvas.addEventListener('pointerdown', this.handleMouseDown);
                document.addEventListener('mousemove', this.handleMouseMove);
                document.addEventListener('pointermove', this.handleMouseMove);
                document.addEventListener('mouseup', this.handleMouseUp);
                document.addEventListener('pointerup',   this.handleMouseUp);
            }
            
            detachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.removeEventListener('mousedown', this.handleMouseDown);
                canvas.removeEventListener('pointerdown', this.handleMouseDown);
                document.removeEventListener('mousemove', this.handleMouseMove);
                document.removeEventListener('pointermove', this.handleMouseMove);
                document.removeEventListener('mouseup', this.handleMouseUp);
                document.removeEventListener('pointerup',   this.handleMouseUp);
                
                // Finish any in-progress drawing
                this.finishDrawing();
            }
            
            handleMouseDown = (e) => {
                e.preventDefault();
                if (e.pointerId != null) {
                e.target.setPointerCapture(e.pointerId);
                }

                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                // Start a new path
                this.currentPath = new PathObject({
                    color: this.settings.color,
                    lineWidth: this.settings.lineWidth,
                    x: coords.x,
                    y: coords.y
                });
                
                this.currentPath.addPoint(coords.x, coords.y);
                this.drawing = true;
                
                // Add to layer
                this.layerSystem.addObject(this.currentPath);
            }
            
            handleMouseMove = (e) => {
                if (!this.drawing || !this.currentPath) return;
                
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                // Add point to path
                this.currentPath.addPoint(coords.x, coords.y);
                
                // Redraw
                this.layerSystem.redrawLayer(this.layerSystem.activeLayerIndex);
            }
            
            handleMouseUp = (e) => {
                if (e.pointerId != null) {
                  e.target.releasePointerCapture(e.pointerId);
                }
                this.finishDrawing();
            }
            
            finishDrawing() {
                if (this.drawing && this.currentPath) {
                    // Finish the path
                    this.drawing = false;
                    this.currentPath = null;
                }
            }
        }
        
        // Line tool
        class LineTool extends DrawingTool {
            constructor(toolSystem) {
                super(toolSystem);
                this.startPoint = null;
                this.currentLine = null;
                this.drawing = false;
            }
            
            attachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.addEventListener('mousedown', this.handleMouseDown);
                document.addEventListener('mousemove', this.handleMouseMove);
                document.addEventListener('mouseup', this.handleMouseUp);
            }
            
            detachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.removeEventListener('mousedown', this.handleMouseDown);
                document.removeEventListener('mousemove', this.handleMouseMove);
                document.removeEventListener('mouseup', this.handleMouseUp);
                
                // Finish any in-progress drawing
                this.finishDrawing();
            }
            
            handleMouseDown = (e) => {
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                this.startPoint = coords;
                
                // Create temporary line
                this.currentLine = new LineObject({
                    x: coords.x,
                    y: coords.y,
                    x2: coords.x,
                    y2: coords.y,
                    color: this.settings.color,
                    lineWidth: this.settings.lineWidth
                });
                
                this.drawing = true;
                
                // Add to layer
                this.layerSystem.addObject(this.currentLine);
            }
            
            handleMouseMove = (e) => {
                if (!this.drawing || !this.currentLine) return;
                
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                // Update end point
                this.currentLine.x2 = coords.x;
                this.currentLine.y2 = coords.y;
                
                // Redraw
                this.layerSystem.redrawLayer(this.layerSystem.activeLayerIndex);
            }
            
            handleMouseUp = () => {
                this.finishDrawing();
            }
            
            finishDrawing() {
                if (this.drawing && this.currentLine) {
                    // Finish the line
                    this.drawing = false;
                    this.startPoint = null;
                    this.currentLine = null;
                }
            }
        }
        
        // Arrow tool (extends Line tool)
        class ArrowTool extends LineTool {
            handleMouseDown = (e) => {
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                this.startPoint = coords;
                
                // Create temporary arrow
                this.currentLine = new ArrowObject({
                    x: coords.x,
                    y: coords.y,
                    x2: coords.x,
                    y2: coords.y,
                    color: this.settings.color,
                    lineWidth: this.settings.lineWidth
                });
                
                this.drawing = true;
                
                // Add to layer
                this.layerSystem.addObject(this.currentLine);
            }
        }
        
        // Rectangle tool
        class RectangleTool extends DrawingTool {
            constructor(toolSystem) {
                super(toolSystem);
                this.startPoint = null;
                this.currentRect = null;
                this.drawing = false;
            }
            
            attachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.addEventListener('mousedown', this.handleMouseDown);
                document.addEventListener('mousemove', this.handleMouseMove);
                document.addEventListener('mouseup', this.handleMouseUp);
            }
            
            detachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.removeEventListener('mousedown', this.handleMouseDown);
                document.removeEventListener('mousemove', this.handleMouseMove);
                document.removeEventListener('mouseup', this.handleMouseUp);
                
                // Finish any in-progress drawing
                this.finishDrawing();
            }
            
            handleMouseDown = (e) => {
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                this.startPoint = coords;
                
                // Create temporary rectangle
                this.currentRect = new RectangleObject({
                    x: coords.x,
                    y: coords.y,
                    width: 0,
                    height: 0,
                    color: this.settings.color,
                    lineWidth: this.settings.lineWidth,
                    fill: this.settings.fill,
                    fillColor: this.settings.fillColor
                });
                
                this.drawing = true;
                
                // Add to layer
                this.layerSystem.addObject(this.currentRect);
            }
            
            handleMouseMove = (e) => {
                if (!this.drawing || !this.currentRect) return;
                
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                // Update dimensions
                const width = coords.x - this.startPoint.x;
                const height = coords.y - this.startPoint.y;
                
                if (width < 0) {
                    this.currentRect.x = coords.x;
                    this.currentRect.width = Math.abs(width);
                } else {
                    this.currentRect.x = this.startPoint.x;
                    this.currentRect.width = width;
                }
                
                if (height < 0) {
                    this.currentRect.y = coords.y;
                    this.currentRect.height = Math.abs(height);
                } else {
                    this.currentRect.y = this.startPoint.y;
                    this.currentRect.height = height;
                }
                
                // Redraw
                this.layerSystem.redrawLayer(this.layerSystem.activeLayerIndex);
            }
            
            handleMouseUp = () => {
                this.finishDrawing();
            }
            
            finishDrawing() {
                if (this.drawing && this.currentRect) {
                    // Finish the rectangle
                    this.drawing = false;
                    this.startPoint = null;
                    this.currentRect = null;
                }
            }
        }
        
        // Ellipse tool
        class EllipseTool extends DrawingTool {
            constructor(toolSystem) {
                super(toolSystem);
                this.center = null;
                this.currentEllipse = null;
                this.drawing = false;
            }
            
            attachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.addEventListener('mousedown', this.handleMouseDown);
                document.addEventListener('mousemove', this.handleMouseMove);
                document.addEventListener('mouseup', this.handleMouseUp);
            }
            
            detachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.removeEventListener('mousedown', this.handleMouseDown);
                document.removeEventListener('mousemove', this.handleMouseMove);
                document.removeEventListener('mouseup', this.handleMouseUp);
                
                // Finish any in-progress drawing
                this.finishDrawing();
            }
            
            handleMouseDown = (e) => {
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                this.center = coords;
                
                // Create temporary ellipse
                this.currentEllipse = new EllipseObject({
                    x: coords.x,
                    y: coords.y,
                    radiusX: 0,
                    radiusY: 0,
                    color: this.settings.color,
                    lineWidth: this.settings.lineWidth,
                    fill: this.settings.fill,
                    fillColor: this.settings.fillColor
                });
                
                this.drawing = true;
                
                // Add to layer
                this.layerSystem.addObject(this.currentEllipse);
            }
            
            handleMouseMove = (e) => {
                if (!this.drawing || !this.currentEllipse) return;
                
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                // Update radii
                this.currentEllipse.radiusX = Math.abs(coords.x - this.center.x);
                this.currentEllipse.radiusY = Math.abs(coords.y - this.center.y);
                
                // Redraw
                this.layerSystem.redrawLayer(this.layerSystem.activeLayerIndex);
            }
            
            handleMouseUp = () => {
                this.finishDrawing();
            }
            
            finishDrawing() {
                if (this.drawing && this.currentEllipse) {
                    // Finish the ellipse
                    this.drawing = false;
                    this.center = null;
                    this.currentEllipse = null;
                }
            }
        }
        
        // Text tool
        class TextTool extends DrawingTool {
            constructor(toolSystem) {
                super(toolSystem);
                this.textInput = null;
            }
            
            attachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.addEventListener('click', this.handleClick);
            }
            
            detachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.removeEventListener('click', this.handleClick);
                
                // Remove any active text input
                this.removeTextInput();
            }
            
            handleClick = (e) => {
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                // Show text input at click position
                this.showTextInput(coords.x, coords.y);
            }
            
            showTextInput(x, y) {
                // Remove any existing text input
                this.removeTextInput();
                
                // Create text input element
                this.textInput = document.createElement('div');
                this.textInput.style.position = 'absolute';
                this.textInput.style.zIndex = '100';
                
                // Position relative to canvas
                const canvasRect = this.layerSystem.container.getBoundingClientRect();
                this.textInput.style.left = (canvasRect.left + x) + 'px';
                this.textInput.style.top = (canvasRect.top + y) + 'px';
                
                // Style the input
                this.textInput.style.backgroundColor = 'white';
                this.textInput.style.border = '1px solid #ccc';
                this.textInput.style.padding = '5px';
                this.textInput.style.borderRadius = '3px';
                this.textInput.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
                
                // Create the actual input
                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = 'Enter text...';
                input.style.width = '200px';
                input.style.padding = '5px';
                input.style.border = '1px solid #ddd';
                input.style.borderRadius = '3px';
                
                // Create font size selector
                const sizeSelect = document.createElement('select');
                [8, 10, 12, 14, 16, 18, 20, 24, 36].forEach(size => {
                    const option = document.createElement('option');
                    option.value = size;
                    option.textContent = size + 'px';
                    if (size === this.settings.fontSize) {
                        option.selected = true;
                    }
                    sizeSelect.appendChild(option);
                });
                
                sizeSelect.addEventListener('change', (e) => {
                    this.settings.fontSize = parseInt(e.target.value);
                });
                
                // Create alignment options
                const alignmentDiv = document.createElement('div');
                alignmentDiv.style.display = 'flex';
                alignmentDiv.style.marginTop = '5px';
                
                ['left', 'center', 'right'].forEach(align => {
                    const button = document.createElement('button');
                    button.textContent = align[0].toUpperCase();
                    button.style.flex = '1';
                    button.style.padding = '2px 5px';
                    button.style.backgroundColor = this.settings.textAlign === align ? '#4CAF50' : '#f1f1f1';
                    button.style.color = this.settings.textAlign === align ? 'white' : 'black';
                    button.style.border = '1px solid #ccc';
                    button.style.cursor = 'pointer';
                    
                    button.addEventListener('click', () => {
                        this.settings.textAlign = align;
                        alignmentDiv.querySelectorAll('button').forEach(btn => {
                            btn.style.backgroundColor = '#f1f1f1';
                            btn.style.color = 'black';
                        });
                        button.style.backgroundColor = '#4CAF50';
                        button.style.color = 'white';
                    });
                    
                    alignmentDiv.appendChild(button);
                });
                
                // Add UI elements to the container
                this.textInput.appendChild(input);
                this.textInput.appendChild(document.createElement('br'));
                this.textInput.appendChild(document.createTextNode('Size: '));
                this.textInput.appendChild(sizeSelect);
                this.textInput.appendChild(document.createElement('br'));
                this.textInput.appendChild(alignmentDiv);
                
                // Add buttons container
                const buttons = document.createElement('div');
                buttons.style.display = 'flex';
                buttons.style.marginTop = '5px';
                buttons.style.gap = '5px';
                
                // Add button
                const addButton = document.createElement('button');
                addButton.textContent = 'Add Text';
                addButton.style.flex = '1';
                addButton.style.padding = '5px';
                addButton.style.backgroundColor = '#4CAF50';
                addButton.style.color = 'white';
                addButton.style.border = 'none';
                addButton.style.borderRadius = '3px';
                addButton.style.cursor = 'pointer';
                
                addButton.addEventListener('click', () => {
                    this.addText(x, y, input.value);
                });
                
                // Cancel button
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.style.flex = '1';
                cancelButton.style.padding = '5px';
                cancelButton.style.backgroundColor = '#f44336';
                cancelButton.style.color = 'white';
                cancelButton.style.border = 'none';
                cancelButton.style.borderRadius = '3px';
                cancelButton.style.cursor = 'pointer';
                
                cancelButton.addEventListener('click', () => {
                    this.removeTextInput();
                });
                
                buttons.appendChild(addButton);
                buttons.appendChild(cancelButton);
                this.textInput.appendChild(buttons);
                
                // Add to document
                document.body.appendChild(this.textInput);
                
                // Focus the input
                input.focus();
                
                // Handle enter key
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.addText(x, y, input.value);
                    } else if (e.key === 'Escape') {
                        this.removeTextInput();
                    }
                });
            }
            
            removeTextInput() {
                if (this.textInput && this.textInput.parentNode) {
                    this.textInput.parentNode.removeChild(this.textInput);
                    this.textInput = null;
                }
            }
            
            addText(x, y, text) {
                if (!text.trim()) {
                    this.removeTextInput();
                    return;
                }
                
                // Create text object
                const textObj = new TextObject({
                    x: x,
                    y: y,
                    text: text,
                    color: this.settings.color,
                    fontSize: this.settings.fontSize,
                    fontFamily: this.settings.fontFamily,
                    align: this.settings.textAlign
                });
                
                // Add to layer
                this.layerSystem.addObject(textObj);
                
                // Remove text input
                this.removeTextInput();
            }
        }
        
        // Image tool
        class ImageTool extends DrawingTool {
            constructor(toolSystem) {
                super(toolSystem);
                this.fileInput = null;
            }
            
            attachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.addEventListener('click', this.handleClick);
            }
            
            detachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.removeEventListener('click', this.handleClick);
            }
            
            handleClick = (e) => {
                // Show file upload dialog
                this.showFileDialog();
            }
            
            showFileDialog() {
                // Create hidden file input if it doesn't exist
                if (!this.fileInput) {
                    this.fileInput = document.createElement('input');
                    this.fileInput.type = 'file';
                    this.fileInput.accept = 'image/*';
                    this.fileInput.style.display = 'none';
                    document.body.appendChild(this.fileInput);
                    
                    this.fileInput.addEventListener('change', (e) => {
                        if (e.target.files && e.target.files[0]) {
                            this.handleFileSelect(e.target.files[0]);
                        }
                    });
                }
                
                // Trigger file dialog
                this.fileInput.click();
            }
            
            handleFileSelect(file) {
                // Read the file and create a data URL
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    const imageUrl = e.target.result;
                    
                    // Show image placement UI
                    this.showImagePlacementUI(imageUrl);
                };
                
                reader.readAsDataURL(file);
            }
            
            showImagePlacementUI(imageUrl) {
                // Create a preview image to get dimensions
                const img = new Image();
                
                img.onload = () => {
                    // Calculate dimensions (max size 300px width/height while maintaining aspect ratio)
                    let width = img.width;
                    let height = img.height;
                    
                    const maxSize = 300;
                    if (width > maxSize || height > maxSize) {
                        if (width > height) {
                            height = (height / width) * maxSize;
                            width = maxSize;
                        } else {
                            width = (width / height) * maxSize;
                            height = maxSize;
                        }
                    }
                    
                    // Create placement UI
                    const placementUI = document.createElement('div');
                    placementUI.style.position = 'fixed';
                    placementUI.style.top = '50%';
                    placementUI.style.left = '50%';
                    placementUI.style.transform = 'translate(-50%, -50%)';
                    placementUI.style.backgroundColor = 'white';
                    placementUI.style.padding = '20px';
                    placementUI.style.borderRadius = '5px';
                    placementUI.style.boxShadow = '0 0 10px rgba(0,0,0,0.3)';
                    placementUI.style.zIndex = '1000';
                    
                    // Add heading
                    const heading = document.createElement('h3');
                    heading.textContent = 'Place Image';
                    heading.style.margin = '0 0 10px 0';
                    
                    // Add image preview
                    const preview = document.createElement('img');
                    preview.src = imageUrl;
                    preview.style.maxWidth = '300px';
                    preview.style.maxHeight = '300px';
                    preview.style.display = 'block';
                    preview.style.marginBottom = '10px';
                    
                    // Size controls
                    const sizeControls = document.createElement('div');
                    sizeControls.style.marginBottom = '10px';
                    
                    const widthLabel = document.createElement('label');
                    widthLabel.textContent = 'Width: ';
                    const widthInput = document.createElement('input');
                    widthInput.type = 'number';
                    widthInput.value = Math.round(width);
                    widthInput.style.width = '60px';
                    
                    const heightLabel = document.createElement('label');
                    heightLabel.textContent = 'Height: ';
                    heightLabel.style.marginLeft = '10px';
                    const heightInput = document.createElement('input');
                    heightInput.type = 'number';
                    heightInput.value = Math.round(height);
                    heightInput.style.width = '60px';
                    
                    // Maintain aspect ratio
                    const aspectRatio = img.width / img.height;
                    
                    widthInput.addEventListener('input', () => {
                        const newWidth = parseInt(widthInput.value);
                        if (!isNaN(newWidth)) {
                            heightInput.value = Math.round(newWidth / aspectRatio);
                        }
                    });
                    
                    heightInput.addEventListener('input', () => {
                        const newHeight = parseInt(heightInput.value);
                        if (!isNaN(newHeight)) {
                            widthInput.value = Math.round(newHeight * aspectRatio);
                        }
                    });
                    
                    sizeControls.appendChild(widthLabel);
                    sizeControls.appendChild(widthInput);
                    sizeControls.appendChild(heightLabel);
                    sizeControls.appendChild(heightInput);
                    
                    // Buttons container
                    const buttons = document.createElement('div');
                    buttons.style.display = 'flex';
                    buttons.style.justifyContent = 'space-between';
                    buttons.style.marginTop = '15px';
                    
                    // Place button
                    const placeButton = document.createElement('button');
                    placeButton.textContent = 'Place Image';
                    placeButton.style.padding = '8px 15px';
                    placeButton.style.backgroundColor = '#4CAF50';
                    placeButton.style.color = 'white';
                    placeButton.style.border = 'none';
                    placeButton.style.borderRadius = '4px';
                    placeButton.style.cursor = 'pointer';
                    
                    placeButton.addEventListener('click', () => {
                        // Get center of view as placement position
                        const containerRect = this.layerSystem.container.getBoundingClientRect();
                        const x = containerRect.width / 2;
                        const y = containerRect.height / 2;
                        
                        // Get dimensions from inputs
                        const finalWidth = parseInt(widthInput.value);
                        const finalHeight = parseInt(heightInput.value);
                        
                        // Create and add image object
                        const imageObj = new ImageObject({
                            x: x - finalWidth / 2,
                            y: y - finalHeight / 2,
                            width: finalWidth,
                            height: finalHeight,
                            imageUrl: imageUrl
                        });
                        
                        this.layerSystem.addObject(imageObj);
                        
                        // Remove UI
                        document.body.removeChild(placementUI);
                    });
                    
                    // Cancel button
                    const cancelButton = document.createElement('button');
                    cancelButton.textContent = 'Cancel';
                    cancelButton.style.padding = '8px 15px';
                    cancelButton.style.backgroundColor = '#f44336';
                    cancelButton.style.color = 'white';
                    cancelButton.style.border = 'none';
                    cancelButton.style.borderRadius = '4px';
                    cancelButton.style.cursor = 'pointer';
                    
                    cancelButton.addEventListener('click', () => {
                        document.body.removeChild(placementUI);
                    });
                    
                    buttons.appendChild(cancelButton);
                    buttons.appendChild(placeButton);
                    
                    // Assemble UI
                    placementUI.appendChild(heading);
                    placementUI.appendChild(preview);
                    placementUI.appendChild(sizeControls);
                    placementUI.appendChild(buttons);
                    
                    // Add to document
                    document.body.appendChild(placementUI);
                };
                
                img.src = imageUrl;
            }
        }
        
        // Symbol tool
        class SymbolTool extends DrawingTool {
            constructor(toolSystem) {
                super(toolSystem);
                this.symbolSelector = null;
            }
            
            attachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.addEventListener('click', this.handleClick);
            }
            
            detachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.removeEventListener('click', this.handleClick);
                
                // Remove any active symbol selector
                this.removeSymbolSelector();
            }
            
            handleClick = (e) => {
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                // Show symbol selector
                this.showSymbolSelector(coords.x, coords.y);
            }
            
            showSymbolSelector(x, y) {
                // Remove existing selector if any
                this.removeSymbolSelector();
                
                // Create symbol selector
                this.symbolSelector = document.createElement('div');
                this.symbolSelector.style.position = 'absolute';
                this.symbolSelector.style.zIndex = '100';
                
                // Position relative to canvas
                const canvasRect = this.layerSystem.container.getBoundingClientRect();
                this.symbolSelector.style.left = (canvasRect.left + x + 10) + 'px';
                this.symbolSelector.style.top = (canvasRect.top + y + 10) + 'px';
                
                // Style
                this.symbolSelector.style.backgroundColor = 'white';
                this.symbolSelector.style.border = '1px solid #ccc';
                this.symbolSelector.style.padding = '10px';
                this.symbolSelector.style.borderRadius = '5px';
                this.symbolSelector.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
                
                // Add title
                const title = document.createElement('h4');
                title.textContent = 'Select Animation Symbol';
                title.style.margin = '0 0 10px 0';
                this.symbolSelector.appendChild(title);
                
                // Symbol grid
                const symbolGrid = document.createElement('div');
                symbolGrid.style.display = 'grid';
                symbolGrid.style.gridTemplateColumns = 'repeat(3, 1fr)';
                symbolGrid.style.gap = '10px';
                symbolGrid.style.marginBottom = '10px';
                
                // Available symbols
                const symbols = [
                    { type: 'anticipation', name: 'Anticipation' },
                    { type: 'impact', name: 'Impact' },
                    { type: 'keyframe', name: 'Keyframe' },
                    { type: 'inbetween', name: 'Inbetween' },
                    { type: 'hold', name: 'Hold' },
                    { type: 'default', name: 'Default' }
                ];
                
                // Create symbol preview for each type
                symbols.forEach(symbol => {
                    const symbolItem = document.createElement('div');
                    symbolItem.style.display = 'flex';
                    symbolItem.style.flexDirection = 'column';
                    symbolItem.style.alignItems = 'center';
                    symbolItem.style.cursor = 'pointer';
                    symbolItem.style.padding = '5px';
                    symbolItem.style.border = '1px solid #ddd';
                    symbolItem.style.borderRadius = '3px';
                    
                    // Create canvas for symbol preview
                    const canvas = document.createElement('canvas');
                    canvas.width = 50;
                    canvas.height = 50;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw symbol preview
                    ctx.save();
                    ctx.strokeStyle = this.settings.color;
                    ctx.fillStyle = this.settings.color;
                    ctx.lineWidth = 2;
                    
                    // Draw centered preview
                    const symbolObj = new SymbolObject({
                        x: 25,
                        y: 25,
                        symbolType: symbol.type,
                        color: this.settings.color,
                        lineWidth: 2,
                        scale: 1.5
                    });
                    
                    symbolObj.draw(ctx);
                    ctx.restore();
                    
                    const name = document.createElement('div');
                    name.textContent = symbol.name;
                    name.style.marginTop = '5px';
                    name.style.fontSize = '12px';
                    
                    symbolItem.appendChild(canvas);
                    symbolItem.appendChild(name);
                    
                    // Add click handler
                    symbolItem.addEventListener('click', () => {
                        this.addSymbol(x, y, symbol.type);
                        this.removeSymbolSelector();
                    });
                    
                    symbolGrid.appendChild(symbolItem);
                });
                
                this.symbolSelector.appendChild(symbolGrid);
                
                // Scale control
                const scaleContainer = document.createElement('div');
                scaleContainer.style.display = 'flex';
                scaleContainer.style.alignItems = 'center';
                scaleContainer.style.marginBottom = '10px';
                
                const scaleLabel = document.createElement('label');
                scaleLabel.textContent = 'Scale: ';
                
                const scaleInput = document.createElement('input');
                scaleInput.type = 'range';
                scaleInput.min = '0.5';
                scaleInput.max = '3';
                scaleInput.step = '0.1';
                scaleInput.value = this.settings.symbolScale;
                scaleInput.style.flex = '1';
                scaleInput.style.marginLeft = '5px';
                
                const scaleValue = document.createElement('span');
                scaleValue.textContent = this.settings.symbolScale + 'x';
                scaleValue.style.marginLeft = '5px';
                scaleValue.style.width = '30px';
                
                scaleInput.addEventListener('input', () => {
                    this.settings.symbolScale = parseFloat(scaleInput.value);
                    scaleValue.textContent = this.settings.symbolScale + 'x';
                });
                
                scaleContainer.appendChild(scaleLabel);
                scaleContainer.appendChild(scaleInput);
                scaleContainer.appendChild(scaleValue);
                
                this.symbolSelector.appendChild(scaleContainer);
                
                // Add cancel button
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.style.width = '100%';
                cancelButton.style.padding = '5px';
                cancelButton.style.backgroundColor = '#f44336';
                cancelButton.style.color = 'white';
                cancelButton.style.border = 'none';
                cancelButton.style.borderRadius = '3px';
                cancelButton.style.cursor = 'pointer';
                
                cancelButton.addEventListener('click', () => {
                    this.removeSymbolSelector();
                });
                
                this.symbolSelector.appendChild(cancelButton);
                
                // Add to document
                document.body.appendChild(this.symbolSelector);
            }
            
            removeSymbolSelector() {
                if (this.symbolSelector && this.symbolSelector.parentNode) {
                    this.symbolSelector.parentNode.removeChild(this.symbolSelector);
                    this.symbolSelector = null;
                }
            }
            
            addSymbol(x, y, symbolType) {
                // Create symbol object
                const symbolObj = new SymbolObject({
                    x: x,
                    y: y,
                    symbolType: symbolType,
                    color: this.settings.color,
                    lineWidth: this.settings.lineWidth,
                    scale: this.settings.symbolScale
                });
                
                // Add to layer
                this.layerSystem.addObject(symbolObj);
            }
        }
        
        // Frame-spanning line tool (for connecting cells across frames)
        class FrameSpanningLineTool extends DrawingTool {
            constructor(toolSystem) {
                super(toolSystem);
                this.startCell = null;
                this.currentLine = null;
                this.drawing = false;
            }
            
            attachEvents() {
                // This tool works with the table cells, not the canvas
                this.setupCellEvents();
            }
            
            detachEvents() {
                this.removeCellEvents();
                
                // Finish any in-progress drawing
                this.finishDrawing();
            }
            
            setupCellEvents() {
                // Find all table cells and add mousedown handler
                const cells = document.querySelectorAll('#xsheet-table td');
                cells.forEach(cell => {
                    cell.addEventListener('mousedown', this.handleCellMouseDown);
                    cell.addEventListener('mouseup', this.handleCellMouseUp);
                    
                    // Add hover effect
                    cell.addEventListener('mouseover', this.handleCellHover);
                    cell.addEventListener('mouseout', this.handleCellOut);
                    
                    // Store original background for hover effect
                    if (!cell.dataset.originalBg) {
                        cell.dataset.originalBg = cell.style.backgroundColor || '';
                    }
                });
            }
            
            removeCellEvents() {
                const cells = document.querySelectorAll('#xsheet-table td');
                cells.forEach(cell => {
                    cell.removeEventListener('mousedown', this.handleCellMouseDown);
                    cell.removeEventListener('mouseup', this.handleCellMouseUp);
                    cell.removeEventListener('mouseover', this.handleCellHover);
                    cell.removeEventListener('mouseout', this.handleCellOut);
                    
                    // Restore original background
                    if (cell.dataset.originalBg) {
                        cell.style.backgroundColor = cell.dataset.originalBg;
                    }
                });
            }
            
            handleCellHover = (e) => {
                const cell = e.currentTarget;
                cell.style.backgroundColor = 'rgba(0, 123, 255, 0.2)';
            }
            
            handleCellOut = (e) => {
                const cell = e.currentTarget;
                if (!this.drawing || cell !== this.startCell) {
                    cell.style.backgroundColor = cell.dataset.originalBg || '';
                }
            }
            
            handleCellMouseDown = (e) => {
                const cell = e.currentTarget;
                
                // Find the row and column index
                const row = cell.parentElement;
                const frameNumber = parseInt(row.getAttribute('data-frame') || row.className.replace('frame-', ''));
                const columnIndex = Array.from(row.children).indexOf(cell) + 1;
                
                if (isNaN(frameNumber) || frameNumber <= 0) return;
                
                // Store as start cell
                this.startCell = cell;
                this.drawing = true;
                
                // Highlight the cell
                cell.style.backgroundColor = 'rgba(0, 123, 255, 0.4)';
                
                // Create temporary frame-spanning line object
                this.currentLine = new FrameSpanningLineObject({
                    startFrame: frameNumber,
                    startColumn: columnIndex,
                    endFrame: frameNumber,
                    endColumn: columnIndex,
                    color: this.settings.color,
                    lineWidth: this.settings.lineWidth,
                    arrowEnd: true
                });
                
                // Add to layer
                this.layerSystem.addObject(this.currentLine);
            }
            
            handleCellMouseUp = (e) => {
                if (!this.drawing || !this.currentLine) return;
                
                const cell = e.currentTarget;
                
                // Skip if this is the same cell
                if (cell === this.startCell) {
                    this.finishDrawing();
                    return;
                }
                
                // Find the row and column index
                const row = cell.parentElement;
                const frameNumber = parseInt(row.getAttribute('data-frame') || row.className.replace('frame-', ''));
                const columnIndex = Array.from(row.children).indexOf(cell) + 1;
                
                if (isNaN(frameNumber) || frameNumber <= 0) {
                    this.finishDrawing();
                    return;
                }
                
                // Update the end point of the line
                this.currentLine.endFrame = frameNumber;
                this.currentLine.endColumn = columnIndex;
                
                // Redraw
                this.layerSystem.redrawLayer(this.layerSystem.activeLayerIndex);
                
                // Finish drawing
                this.finishDrawing();
            }
            
            finishDrawing() {
                if (this.drawing) {
                    // Reset flags
                    this.drawing = false;
                    
                    // If the line is too short (same start and end), remove it
                    if (this.currentLine && 
                        this.currentLine.startFrame === this.currentLine.endFrame && 
                        this.currentLine.startColumn === this.currentLine.endColumn) {
                        this.layerSystem.removeObject(this.currentLine);
                    }
                    
                    // Clear current line reference
                    this.currentLine = null;
                    
                    // Reset cell highlights
                    if (this.startCell) {
                        this.startCell.style.backgroundColor = this.startCell.dataset.originalBg || '';
                        this.startCell = null;
                    }
                }
            }
        }
        
        // Eraser tool
        class EraserTool extends DrawingTool {
            constructor(toolSystem) {
                super(toolSystem);
            }
            
            attachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.addEventListener('mousedown', this.handleMouseDown);
            }
            
            detachEvents() {
                const canvas = this.layerSystem.getActiveLayer().canvas;
                
                canvas.removeEventListener('mousedown', this.handleMouseDown);
            }
            
            handleMouseDown = (e) => {
                const coords = this.layerSystem.screenToCanvas(e.clientX, e.clientY);
                
                // Find object at click position
                const hit = this.layerSystem.findObjectAt(coords.x, coords.y);
                
                if (hit) {
                    // Remove the object
                    this.layerSystem.removeObject(hit.object, hit.layerIndex);
                }
            }
        }
        
        /**
         * INTEGRATION WITH X-SHEET APPLICATION
         * Initialize the drawing system, save/load integration, and PDF/print handling
         */
        
        // Initialize drawing system when document is loaded
        function initDrawingSystem() {
            // Setup after the table is rendered
            setTimeout(() => {
                // Get the X-Sheet table element
                const xsheetTable = document.getElementById('xsheet-table');
                if (!xsheetTable) {
                    console.error('X-Sheet table not found');
                    return;
                }
                
                // Create drawing systems
                const drawingLayerSystem = new DrawingLayerSystem(xsheetTable);
                const drawingToolSystem = new DrawingToolSystem(drawingLayerSystem);
                
                // Store global reference
                window.xsheetDrawing = {
                    layerSystem: drawingLayerSystem,
                    toolSystem: drawingToolSystem
                };
                
                // Add to status message
                const statusElement = document.getElementById('status-message');
                if (statusElement) {
                    statusElement.textContent = 'Drawing tools initialized';
                }
                
                // Integrate with X-Sheet save/load system
                integrateWithXSheetSaveLoad();
                
                // Integrate with X-Sheet PDF and printing
                integrateWithXSheetExport();
                
                // Custom event for when drawing objects change
                document.addEventListener('xsheet-redraw', function() {
                    drawingLayerSystem.redrawAll();
                });
                
                console.log('Drawing tools initialized successfully');
            }, 500);
        }
        
        // Integrate drawing data with X-Sheet save/load system
        function integrateWithXSheetSaveLoad() {
            // Store original functions
            const originalCollectData = window.collectData;
            const originalRestoreData = window.restoreData;
            
            // Override collectData to include drawings
            window.collectData = function() {
                // Call original function to get base data
                const data = originalCollectData ? originalCollectData() : {};
                
                // Add drawing data if drawing system is initialized
                if (window.xsheetDrawing && window.xsheetDrawing.layerSystem) {
                    data.drawingLayers = [];
                    
                    // Collect objects from each layer
                    window.xsheetDrawing.layerSystem.layers.forEach(layer => {
                        const layerData = {
                            name: layer.name,
                            visible: layer.visible,
                            objects: layer.objects.map(obj => obj.toJSON())
                        };
                        
                        data.drawingLayers.push(layerData);
                    });
                }
                
                return data;
            };
            
            // Override restoreData to handle drawings
            window.restoreData = function(data) {
                // Call original function to restore base data
                if (originalRestoreData) {
                    originalRestoreData(data);
                }
                
                // Restore drawing data if available
                if (data.drawingLayers && window.xsheetDrawing && window.xsheetDrawing.layerSystem) {
                    const layerSystem = window.xsheetDrawing.layerSystem;
                    
                    // Clear existing layers
                    layerSystem.clearAllLayers();
                    
                    // Restore each layer
                    data.drawingLayers.forEach((layerData, index) => {
                        // Create layer if needed
                        if (index >= layerSystem.layers.length) {
                            layerSystem.addLayer(layerData.name);
                        } else {
                            layerSystem.layers[index].name = layerData.name;
                            layerSystem.layers[index].visible = layerData.visible;
                        }
                        
                        // Restore objects
                        layerData.objects.forEach(objData => {
                            const newObj = DrawingObjectFactory.createFromJSON(objData);
                            if (newObj) {
                                layerSystem.layers[index].objects.push(newObj);
                            }
                        });
                    });
                    
                    // Redraw
                    layerSystem.redrawAll();
                }
            };
        }
        
        // Integrate drawing layers with PDF export and printing
        function integrateWithXSheetExport() {
            // Store original functions
            const originalExportToPDF = window.exportToPDF;
            const originalPrintSheet = window.printSheet;
            
            // Override PDF export to include drawings
        window.exportToPDF = function() {
            if (!window.xsheetDrawing || !window.xsheetDrawing.layerSystem) {
                return originalExportToPDF ? originalExportToPDF() : null;
            }

            // Save current state
            const layerContainer  = window.xsheetDrawing.layerSystem.container;

            // 1) Save original CSS & DOM parent
            const originalDisplay = layerContainer.style.display;
            const originalPos     = layerContainer.style.position;
            const originalTop     = layerContainer.style.top;
            const originalLeft    = layerContainer.style.left;
            const originalZIndex  = layerContainer.style.zIndex;
            const originalWidth   = layerContainer.style.width;
            const originalHeight  = layerContainer.style.height;
            const originalParent  = layerContainer.parentNode;

            // 2) Make it visible for capture
            layerContainer.style.display = 'block';

            // 3) Compute offsets
            const printableArea  = document.getElementById('printable-area');
            const printableRect  = printableArea.getBoundingClientRect();
            const containerRect  = layerContainer.getBoundingClientRect();

            // 4) Reparent into the printable area
            printableArea.appendChild(layerContainer);

            // 5) Anchor overlay flush to the sheet â€“ no pixel offsets
            layerContainer.style.position = 'absolute';
            layerContainer.style.inset = '0';   // top/right/bottom/left = 0
            layerContainer.style.width = '100%';
            layerContainer.style.height = '100%';
            layerContainer.style.zIndex = '1000';

            // 6) Generate the PDF
            const result = originalExportToPDF ? originalExportToPDF() : null;

            // 7) Restore everything
            layerContainer.style.display  = originalDisplay;
            // 6) Force absolute positioning & lock size
            layerContainer.style.position = 'absolute';
            layerContainer.style.top = '0';      // <â€” replace previous pixel math
            layerContainer.style.left = '0';
            layerContainer.style.width = '100%';   // match parent width
            layerContainer.style.height = '100%';   // match parent height
            layerContainer.style.zIndex = '1000';
            originalParent.appendChild(layerContainer);

            return result;
        };  // â† closes exportToPDF

        }  // â† closes integrateWithXSheetExport


            
            // Override print to include drawings
        window.printSheet = function() {
            // 1) Fallback if no drawing system
            if (!window.xsheetDrawing || !window.xsheetDrawing.layerSystem) {
                return originalPrintSheet ? originalPrintSheet() : null;
            }

            // 2) Grab the container and save its original state
            const layerContainer = window.xsheetDrawing.layerSystem.container;
            const originalDisplay= layerContainer.style.display;
            const originalPos    = layerContainer.style.position;
            const originalTop    = layerContainer.style.top;
            const originalLeft   = layerContainer.style.left;
            const originalZIndex = layerContainer.style.zIndex;
            const originalWidth  = layerContainer.style.width;
            const originalHeight = layerContainer.style.height;
            const originalParent = layerContainer.parentNode;

            // 3) Make it visible for print capture
            layerContainer.style.display = 'block';

            // 4) Compute offsets relative to the sheet
            const printableArea = document.getElementById('printable-area');
            const printableRect = printableArea.getBoundingClientRect();
            const containerRect = layerContainer.getBoundingClientRect();

            // 5) Reparent into the printable-area element
            printableArea.appendChild(layerContainer);

            // 6) Force absolute positioning & lock size
            layerContainer.style.position = 'absolute';
            layerContainer.style.top      = `${containerRect.top  - printableRect.top}px`;
            layerContainer.style.left     = `${containerRect.left - printableRect.left}px`;
            layerContainer.style.width    = `${containerRect.width}px`;
            layerContainer.style.height   = `${containerRect.height}px`;
            layerContainer.style.zIndex   = '1000';

            // 7) Call the original print
            const result = originalPrintSheet ? originalPrintSheet() : null;

            // 8) Restore everything back
            layerContainer.style.display  = originalDisplay;
            layerContainer.style.position = originalPos;
            layerContainer.style.top      = originalTop;
            layerContainer.style.left     = originalLeft;
            layerContainer.style.zIndex   = originalZIndex;
            layerContainer.style.width    = originalWidth;
            layerContainer.style.height   = originalHeight;
            originalParent.appendChild(layerContainer);

            return result;
        };  // â† closes printSheet override

        
        // Setup event listeners for table updates
        function setupXSheetUpdateHandling() {
            // Hook into existing update functions
            if (typeof window.generateTable === 'function') {
                const originalGenerateTable = window.generateTable;
                window.generateTable = function() {
                    // Call original function
                    const result = originalGenerateTable.apply(this, arguments);
                    
                    // Fire update event
                    document.dispatchEvent(new Event('xsheet-updated'));
                    
                    return result;
                };
            }
            
            if (typeof window.addEightRows === 'function') {
                const originalAddEightRows = window.addEightRows;
                window.addEightRows = function() {
                    // Call original function
                    const result = originalAddEightRows.apply(this, arguments);
                    
                    // Fire update event
                    document.dispatchEvent(new Event('xsheet-updated'));
                    
                    return result;
                };
            }
            
            if (typeof window.updateTemplate === 'function') {
                const originalUpdateTemplate = window.updateTemplate;
                window.updateTemplate = function() {
                    // Call original function
                    const result = originalUpdateTemplate.apply(this, arguments);
                    
                    // Fire update event
                    document.dispatchEvent(new Event('xsheet-updated'));
                    
                    return result;
                };
            }
        }
        
        // Original X-Sheet code
        // Wait for page load and libraries to initialize
        document.addEventListener('DOMContentLoaded', function () {
            // Global variables
            let frameCount = 96;
            let projectName = 'Animation_XSheet_' + new Date().toISOString().split('T')[0];
            let modified = false;
            let currentTemplate = 'large';

            // Audio variables
            let audioContext = null;
            let audioBuffer = null;
            let audioSource = null;
            let audioData = null;
            let isPlaying = false;
            let startTime = 0;
            let startOffset = 0;
            let audioFileName = '';
            let waveformData = [];
            let waveformCanvases = [];
            let phonetics = [];
            let frameDuration = 1 / 24; // 24fps
            let currentFrame = 0;
            let phoneticEditPosition = null;

            // Initialize UI elements
            const templateSelector = document.getElementById('template-selector');
            const frameCountInput = document.getElementById('frame-count');
            const saveButton = document.getElementById('save-button');
            const loadButton = document.getElementById('load-button');
            const pdfButton = document.getElementById('pdf-button');
            const printButton = document.getElementById('print-button');
            const addRowsButton = document.getElementById('add-rows-button');
            const clearButton = document.getElementById('clear-button');
            const tableBody = document.getElementById('xsheet-body');
            const statusMessage = document.getElementById('status-message');
            const audioButton = document.getElementById('audio-button');
            const audioUpload = document.getElementById('audio-upload');
            const playAudioButton = document.getElementById('play-audio');
            const stopAudioButton = document.getElementById('stop-audio');
            const audioScrubber = document.getElementById('audio-scrubber');
            const audioInfo = document.getElementById('audio-info');
            const addPhoneticButton = document.getElementById('add-phonetic');
            const phoneticInput = document.getElementById('phonetic-input');
            const phoneticText = document.getElementById('phonetic-text');
            const savePhoneticButton = document.getElementById('save-phonetic');
            const cancelPhoneticButton = document.getElementById('cancel-phonetic');

            // Date field - set today by default
            const dateField = document.getElementById('project-date');
            dateField.valueAsDate = new Date();

            // Initialize the table
            generateTable(frameCount);
            
            // Initialize the drawing system
            initDrawingSystem();
            setupXSheetUpdateHandling();

            // Event Listeners
            templateSelector.addEventListener('change', function () {
                currentTemplate = this.value;
                updateTemplate();
            });

            frameCountInput.addEventListener('change', function () {
                frameCount = parseInt(this.value);
                if (frameCount < 8) frameCount = 8;
                generateTable(frameCount);
                updateStatusMessage('Frame count updated to ' + frameCount);

                // Re-render waveform if audio is loaded
                if (audioBuffer) {
                    renderWaveform();
                }
            });

            saveButton.addEventListener('click', saveProject);
            loadButton.addEventListener('click', loadProject);
            pdfButton.addEventListener('click', exportToPDF);
            printButton.addEventListener('click', printSheet);
            addRowsButton.addEventListener('click', addEightRows);
            clearButton.addEventListener('click', clearSheet);

            // Audio related event listeners
            audioButton.addEventListener('click', function () {
                audioUpload.click();
            });

            audioUpload.addEventListener('change', function (e) {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    audioFileName = file.name;
                    loadAudioFile(file);
                }
            });

            playAudioButton.addEventListener('click', togglePlayAudio);
            stopAudioButton.addEventListener('click', stopAudio);
            audioScrubber.addEventListener('input', scrubAudio);

            addPhoneticButton.addEventListener('click', function () {
                if (audioBuffer) {
                    showPhoneticInput(null);
                } else {
                    updateStatusMessage('Please load audio first');
                }
            });

            savePhoneticButton.addEventListener('click', savePhoneticMarker);
            cancelPhoneticButton.addEventListener('click', function () {
                phoneticInput.style.display = 'none';
            });

            // Monitor for changes to set modified flag
            document.addEventListener('input', function (e) {
                if (!e.target.matches('input, [contenteditable="true"]')) return;
                modified = true;

                if (e.target.matches('[contenteditable="true"]')) {
                    // Add the modified class when content is added
                    e.target.classList.add('modified');

                    // Remove the modified class when the cell is empty
                    if (e.target.textContent.trim() === '') {
                        e.target.classList.remove('modified');
                    }
                }

                updateStatusMessage('Changes detected - not saved');
            });

            // Variables for cell selection
            let selectedCells = [];
            let isSelecting = false;
            let selectionStart = null;
            let hasMovedDuringSelection = false;

            // Set up multi-cell selection functionality
            function setupCellSelection() {
                const editableCells = document.querySelectorAll('[contenteditable="true"]');

                // Clear selected cells when clicking outside
                document.addEventListener('click', function (e) {
                    // If this was part of a drag operation, skip the click handler
                    if (hasMovedDuringSelection) {
                        // We removed this line to fix the selection issue
                        // hasMovedDuringSelection = false;
                        return;
                    }

                    // Get the clicked element and check if it's inside an editable cell or a selected cell
                    const clickedCell = e.target.closest('[contenteditable="true"]');
                    const clickedInSelection = e.target.closest('.selected-cell');

                    // If not clicking in a cell or selection and not using modifier keys
                    if (!clickedCell && !clickedInSelection && !e.ctrlKey && !e.metaKey) {
                        clearCellSelection();
                    }
                });

                // Handle clicks on the table for better cell focusing
                document.getElementById('xsheet-table').addEventListener('click', function (e) {
                    // Find the closest editable cell from the click point
                    const targetCell = e.target.closest('[contenteditable="true"]');

                    // If we found a cell and we're not in multi-select mode
                    if (targetCell && !hasMovedDuringSelection && !e.ctrlKey && !e.metaKey) {
                        // Focus the cell and position cursor at the end
                        if (selectedCells.length === 1 && selectedCells[0] === targetCell) {
                            // If already selected, just ensure focus
                            targetCell.focus();
                            placeCaretAtEnd(targetCell);
                        }
                    }
                });

                // Helper function to place caret at the end of content
                function placeCaretAtEnd(el) {
                    if (document.createRange) {
                        const range = document.createRange();
                        range.selectNodeContents(el);
                        range.collapse(false); // false means collapse to end
                        const selection = window.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }

                // Handle mousedown for selection start
                editableCells.forEach(cell => {
                    // Mousedown - start potential selection
                    cell.addEventListener('mousedown', function (e) {
                        // Only handle left mouse button
                        if (e.button !== 0) return;

                        // If using modifier keys for multi-select
                        if (e.ctrlKey || e.metaKey) {
                            toggleCellSelection(cell);
                            e.preventDefault(); // Prevent text cursor
                            return;
                        }

                        // Clear previous selection unless clicking on already selected cell
                        if (!cell.classList.contains('selected-cell')) {
                            clearCellSelection();
                        }

                        // Store starting cell and reset movement flag
                        selectionStart = cell;
                        hasMovedDuringSelection = false;
                        isSelecting = true;

                        // Initially add this cell to selection
                        if (!cell.classList.contains('selected-cell')) {
                            toggleCellSelection(cell, true);
                        }

                        // If it's a single click (not start of drag), focus the cell
                        cell.focus();

                        // Don't prevent default here to allow normal focus behavior
                    });

                    // Additional keyboard events for selected cells
                    cell.addEventListener('keydown', function (e) {
                        // If Delete or Backspace key and we have selected cells
                        if ((e.key === 'Delete' || e.key === 'Backspace') && selectedCells.length > 1) {
                            e.preventDefault();
                            clearSelectedCellsContent();
                        }

                        // Copy with Ctrl+C or Cmd+C
                        if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selectedCells.length > 0) {
                            e.preventDefault();
                            copySelectedCells();
                        }

                        // Select all cells in row with Ctrl+A or Cmd+A
                        if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                            e.preventDefault();
                            selectRowCells(cell.parentElement);
                        }
                    });
                });

                // Global mousemove handler for extending selection
                document.addEventListener('mousemove', function (e) {
                    if (!isSelecting) return;

                    // Set the flag that we've moved during this selection
                    hasMovedDuringSelection = true;

                    // Find the element under the cursor
                    const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
                    if (!elementUnderCursor) return;

                    // Find the closest editable cell
                    const targetCell = elementUnderCursor.closest('[contenteditable="true"]');
                    if (targetCell) {
                        // Add to selection
                        toggleCellSelection(targetCell, true);

                        // Prevent text selection during drag
                        e.preventDefault();
                        if (window.getSelection) {
                            window.getSelection().removeAllRanges();
                        }
                    }
                });

                // Global mouseup to end selection - THIS IS THE FIXED VERSION
                document.addEventListener('mouseup', function (e) {
                    // End selection mode but keep selected cells
                    if (isSelecting) {
                        isSelecting = false;

                        // FIX: Use setTimeout to delay resetting the hasMovedDuringSelection flag
                        // This gives the click handler a chance to see the flag first
                        if (hasMovedDuringSelection) {
                            setTimeout(function () {
                                hasMovedDuringSelection = false;
                            }, 10);
                        }

                        // If this wasn't a drag and there's only one cell selected, focus it
                        if (!hasMovedDuringSelection && selectedCells.length === 1) {
                            const cell = selectedCells[0];
                            cell.focus();
                            placeCaretAtEnd(cell);
                        }
                    }

                    selectionStart = null;
                });

                // Listen for paste events
                document.addEventListener('paste', function (e) {
                    if (selectedCells.length > 0) {
                        handlePaste(e);
                    }
                });
            }

            function toggleCellSelection(cell, addOnly = false) {
                const index = selectedCells.indexOf(cell);

                if (index === -1) {
                    // Add to selection
                    selectedCells.push(cell);
                    cell.classList.add('selected-cell');
                } else if (!addOnly) {
                    // Remove from selection if not add-only mode
                    selectedCells.splice(index, 1);
                    cell.classList.remove('selected-cell');
                }
            }

            function clearCellSelection() {
                selectedCells.forEach(cell => {
                    cell.classList.remove('selected-cell');
                });
                selectedCells = [];
            }

            function clearSelectedCellsContent() {
                selectedCells.forEach(cell => {
                    cell.textContent = '';
                    cell.classList.remove('modified');
                });
                modified = true;
                updateStatusMessage('Cleared selected cells');
            }

            function copySelectedCells() {
                if (selectedCells.length === 0) return;

                // Create a text representation of selected cells
                const cellData = selectedCells.map(cell => cell.textContent || '').join('\t');

                // Copy to clipboard using Clipboard API
                navigator.clipboard.writeText(cellData)
                    .then(() => {
                        updateStatusMessage('Copied selected cells to clipboard');
                    })
                    .catch(err => {
                        updateStatusMessage('Failed to copy: ' + err);
                    });
            }

            function handlePaste(e) {
                // Prevent default paste behavior
                e.preventDefault();

                // Get clipboard data
                const clipboardData = e.clipboardData || window.clipboardData;
                const pastedText = clipboardData.getData('text');

                // If we have a focused element within selection, paste there
                const activeElement = document.activeElement;
                if (activeElement && selectedCells.includes(activeElement)) {
                    activeElement.textContent = pastedText;
                    activeElement.classList.add('modified');
                    modified = true;
                } else if (selectedCells.length > 0) {
                    // Otherwise paste into first selected cell
                    selectedCells[0].textContent = pastedText;
                    selectedCells[0].classList.add('modified');
                    modified = true;
                }

                if (pastedText.trim() === '') {
                    selectedCells.forEach(cell => {
                        cell.classList.remove('modified');
                    });
                }

                updateStatusMessage('Pasted content into selected cell');
            }

            function selectRowCells(row) {
                // Clear previous selection
                clearCellSelection();

                // Select all editable cells in the row
                const cells = Array.from(row.cells).filter(cell => cell.contentEditable === 'true');
                cells.forEach(cell => {
                    toggleCellSelection(cell, true);
                });
            }

            // Functions
            function generateTable(frames) {
                tableBody.innerHTML = '';
                waveformCanvases = [];

                // Create a column container for the waveform
                const waveformColContainer = document.createElement('div');
                waveformColContainer.className = 'waveform-col-container';

                for (let i = 1; i <= frames; i++) {
                    const row = document.createElement('tr');
                    row.className = `frame-${i}`;
                    row.setAttribute('data-frame', i);

                    // Create standard cell
                    function createCell(className, isEditable = true, frameNum = null) {
                        const cell = document.createElement('td');
                        cell.className = className;

                        if (isEditable) {
                            cell.contentEditable = true;
                            cell.setAttribute('data-placeholder', '');
                            cell.setAttribute('tabindex', '0');
                        } else if (frameNum !== null) {
                            cell.textContent = frameNum;
                            cell.className += ' frame-number';

                            // Color the first frame green for reference (like in the example image)
                            if (frameNum === 1) {
                                cell.style.backgroundColor = '#00cc00';
                            } else {
                                cell.style.backgroundColor = '#cccccc';
                            }
                        }

                        return cell;
                    }

                    // Create waveform cell (placeholder for the vertical waveform)
                    function createWaveformCell(frameNum) {
                        const cell = document.createElement('td');
                        cell.className = 'waveform-col';
                        cell.setAttribute('data-frame', frameNum);
                        return cell;
                    }

                    // Add all cells to the row
                    row.appendChild(createCell('action-col'));
                    row.appendChild(createCell('frame-col', false, i));
                    row.appendChild(createWaveformCell(i));
                    row.appendChild(createCell('dialogue-col'));
                    row.appendChild(createCell('sound-col'));
                    row.appendChild(createCell('technical-col'));
                    row.appendChild(createCell('extra1-col'));
                    row.appendChild(createCell('extra2-col'));
                    row.appendChild(createCell('frame-col', false, i));
                    row.appendChild(createCell('camera-col'));

                    // Add special styling for 8-frame and 24-frame intervals
                    if (i % 24 === 0) {
                        row.style.borderBottom = '4px double #000';
                        for (let cell of row.cells) {
                            cell.style.borderBottom = '4px double #000';
                            cell.style.fontWeight = 'bold';
                        }
                    } else if (i % 8 === 0) {
                        row.style.borderBottom = '2px solid #000';
                        for (let cell of row.cells) {
                            cell.style.borderBottom = '2px solid #000';
                            cell.style.fontWeight = 'bold';
                        }
                    }

                    tableBody.appendChild(row);
                }

                setupCellNavigation();
                updateStatusMessage('Table generated with ' + frames + ' frames');
                
                // Fire custom event for drawing system to update
                document.dispatchEvent(new Event('xsheet-updated'));
            }

            function updateTemplate() {
                if (currentTemplate === 'large') {
                    // 11"x17" template (96 frames)
                    document.body.style.maxWidth = '11in';
                    document.body.style.maxHeight = '17in';
                    document.body.style.fontSize = '9pt';
                    frameCountInput.value = 96;
                    frameCount = 96;
                } else {
                    // 8"x10" template (48 frames)
                    document.body.style.maxWidth = '8in';
                    document.body.style.maxHeight = '10in';
                    document.body.style.fontSize = '8pt';
                    frameCountInput.value = 48;
                    frameCount = 48;
                }

                generateTable(frameCount);
                updateStatusMessage('Template switched to ' + (currentTemplate === 'large' ? '11"x17"' : '8"x10"'));

                // Re-render waveform if audio is loaded
                if (audioBuffer) {
                    renderWaveform();
                }
            }

            function setupCellNavigation() {
                const editableCells = document.querySelectorAll('[contenteditable="true"]');

                editableCells.forEach(cell => {
                    cell.addEventListener('keydown', function (e) {
                        // Tab navigation
                        if (e.key === 'Tab') {
                            e.preventDefault();
                            const currentRow = this.parentElement;
                            const currentIndex = Array.from(currentRow.cells).indexOf(this);

                            if (e.shiftKey) {
                                // Shift+Tab moves backward
                                let prevCell = null;
                                if (currentIndex > 0) {
                                    // Find previous editable cell in same row
                                    for (let i = currentIndex - 1; i >= 0; i--) {
                                        if (currentRow.cells[i].contentEditable === 'true') {
                                            prevCell = currentRow.cells[i];
                                            break;
                                        }
                                    }
                                }

                                if (!prevCell) {
                                    // Move to previous row, last cell
                                    const prevRow = currentRow.previousElementSibling;
                                    if (prevRow) {
                                        const cells = Array.from(prevRow.cells).filter(c => c.contentEditable === 'true');
                                        prevCell = cells[cells.length - 1];
                                    }
                                }

                                if (prevCell) {
                                    prevCell.focus();
                                    // Place cursor at end of content
                                    const range = document.createRange();
                                    const sel = window.getSelection();
                                    range.selectNodeContents(prevCell);
                                    range.collapse(false);
                                    sel.removeAllRanges();
                                    sel.addRange(range);
                                }
                            } else {
                                // Tab moves forward
                                let nextCell = null;
                                if (currentIndex < currentRow.cells.length - 1) {
                                    // Find next editable cell in same row
                                    for (let i = currentIndex + 1; i < currentRow.cells.length; i++) {
                                        if (currentRow.cells[i].contentEditable === 'true') {
                                            nextCell = currentRow.cells[i];
                                            break;
                                        }
                                    }
                                }

                                if (!nextCell) {
                                    // Move to next row, first cell
                                    const nextRow = currentRow.nextElementSibling;
                                    if (nextRow) {
                                        nextCell = Array.from(nextRow.cells).find(c => c.contentEditable === 'true');
                                    }
                                }

                                if (nextCell) {
                                    nextCell.focus();
                                }
                            }
                        }

                        // Enter key to move down
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            const currentRow = this.parentElement;
                            const nextRow = currentRow.nextElementSibling;
                            const currentIndex = Array.from(currentRow.cells).indexOf(this);

                            if (nextRow) {
                                const cells = Array.from(nextRow.cells);
                                const samePositionCell = cells[currentIndex];
                                if (samePositionCell && samePositionCell.contentEditable === 'true') {
                                    samePositionCell.focus();
                                }
                            }
                        }
                    });

                    // Add listener to remove the modified class when cell is emptied
                    cell.addEventListener('keyup', function (e) {
                        if ((e.key === 'Delete' || e.key === 'Backspace') && this.textContent.trim() === '') {
                            this.classList.remove('modified');
                        }
                    });
                });

                // Setup cell selection functionality
                setupCellSelection();
            }

            // Audio functions
            function loadAudioFile(file) {
                if (!audioContext) {
                    try {
                        window.AudioContext = window.AudioContext || window.webkitAudioContext;
                        audioContext = new AudioContext();
                    } catch (e) {
                        updateStatusMessage('Web Audio API is not supported in this browser');
                        return;
                    }
                }

                const reader = new FileReader();

                reader.onload = function (e) {
                    const audioData = e.target.result;

                    // Update status
                    updateStatusMessage('Decoding audio...');

                    // Decode the audio data
                    audioContext.decodeAudioData(audioData, function (buffer) {
                        audioBuffer = buffer;

                        // Update audio info
                        const duration = buffer.duration;
                        const minutes = Math.floor(duration / 60);
                        const seconds = Math.floor(duration % 60);
                        const frameCount = Math.ceil(duration * 24); // Assuming 24fps

                        audioInfo.textContent = `${audioFileName} (${minutes}:${seconds.toString().padStart(2, '0')}, ${frameCount} frames @ 24fps)`;

                        // Enable audio controls
                        playAudioButton.disabled = false;
                        stopAudioButton.disabled = false;
                        audioScrubber.disabled = false;

                        // Generate waveform visualization
                        generateWaveformData(buffer);

                        // Update status
                        updateStatusMessage('Audio loaded: ' + audioFileName);

                        // If the x-sheet has fewer frames than the audio, suggest increasing
                        if (frameCount > frameCountInput.value) {
                            if (confirm(`This audio is ${frameCount} frames long at 24fps, but your X-sheet only has ${frameCountInput.value} frames. Do you want to increase the frame count?`)) {
                                frameCountInput.value = frameCount;
                                frameCount = frameCount;
                                generateTable(frameCount);
                                renderWaveform();
                            } else {
                                renderWaveform();
                            }
                        } else {
                            renderWaveform();
                        }
                    }, function (e) {
                        updateStatusMessage('Error decoding audio: ' + e.message);
                    });
                };

                reader.onerror = function () {
                    updateStatusMessage('Error reading audio file');
                };

                reader.readAsArrayBuffer(file);
            }

            function generateWaveformData(buffer) {
                // Get the raw audio data from the buffer
                const rawData = buffer.getChannelData(0); // Use first channel

                // Calculate how many samples we need for our visualization
                const totalSamples = rawData.length;

                // Process for visualization - we need to reduce the resolution
                // to make it efficient to display
                waveformData = [];

                // Calculate desired number of points for the visualization
                // For vertical waveform, we want more detail
                const pointsPerSecond = 100; // Increase detail for vertical display
                const totalPoints = Math.ceil(buffer.duration * pointsPerSecond);

                // Calculate step size
                const step = Math.floor(totalSamples / totalPoints);

                // Build the waveform data array
                for (let i = 0; i < totalPoints; i++) {
                    const index = Math.floor(i * step);
                    if (index < totalSamples) {
                        // Get the absolute value for a nicer visual
                        waveformData.push(Math.abs(rawData[index]));
                    }
                }
            }

            function renderWaveform() {
                if (!audioBuffer || waveformData.length === 0) return;

                // Clear existing markers and components
                const existingMarkers = document.querySelectorAll('.waveform-marker');
                existingMarkers.forEach(marker => marker.remove());

                const existingLabels = document.querySelectorAll('.phonetic-label');
                existingLabels.forEach(label => label.remove());

                const existingContainer = document.querySelector('.waveform-container');
                if (existingContainer) {
                    existingContainer.remove();
                }

                // Get the table and first waveform column cell for positioning
                const table = document.getElementById('xsheet-table');
                const firstCell = document.querySelector('.waveform-col[data-frame="1"]');
                if (!firstCell) return;

                // Calculate total height needed for the waveform
                const totalRows = document.querySelectorAll('tr[data-frame]').length;
                const rowHeight = firstCell.offsetHeight;
                const totalHeight = totalRows * rowHeight;

                // Create a container for the vertical waveform that spans the entire table
                const waveformContainer = document.createElement('div');
                waveformContainer.className = 'waveform-container';

                // Create a canvas for the waveform
                const canvas = document.createElement('canvas');
                canvas.className = 'waveform-canvas';
                canvas.width = firstCell.offsetWidth;
                canvas.height = totalHeight;
                waveformContainer.appendChild(canvas);

                // Add overlay for event handling
                const overlay = document.createElement('div');
                overlay.className = 'waveform-overlay';
                overlay.style.height = totalHeight + 'px';

                // Add event listener for clicking on the waveform
                overlay.addEventListener('click', function (e) {
                    if (!audioBuffer) return;

                    const rect = overlay.getBoundingClientRect();
                    const y = e.clientY - rect.top;
                    const percentage = y / rect.height;

                    // Calculate time point in the audio
                    const timePoint = percentage * audioBuffer.duration;

                    // Update audio position
                    audioScrubber.value = (timePoint / audioBuffer.duration) * 100;
                    if (isPlaying) {
                        stopAudio();
                        startOffset = timePoint;
                        playAudio();
                    } else {
                        startOffset = timePoint;
                    }

                    // Update the UI to show frame position
                    updateFrameMarker();
                });

                // Variables for scrubbing
                let isScrubbing = false;

                // Add scrubbing functionality (dragging while holding mouse button)
                overlay.addEventListener('mousedown', function (e) {
                    if (!audioBuffer) return;
                    if (e.button !== 0) return; // Only respond to left mouse button

                    isScrubbing = true;

                    // Pause any playing audio
                    if (isPlaying) {
                        pauseAudio();
                    }
                    // â€” NEW: allow pen (pointerType="pen") to scrub as well â€”
                    overlay.addEventListener('pointerdown', function (e) {
                        if (!audioBuffer || e.pointerType !== 'pen') return;
                        isScrubbing = true;
                        if (isPlaying) pauseAudio();          // pause continuous playback
                        updateScrubPosition(e);               // scrub to this location
                        e.preventDefault();                   // prevent default pen behavior
                    });
                    overlay.addEventListener('pointermove', function (e) {
                        // â€” FIX: only scrub while the pen is physically pressing (pressure>0)
                        if (isScrubbing && e.pointerType === 'pen' && e.pressure > 0) {
                            updateScrubPosition(e);
                        }
                    });
                    overlay.addEventListener('pointerup', function (e) {
                        if (e.pointerType === 'pen') {
                            isScrubbing = false;
                        }
                    });

                    // Create a scrub audio context if needed
                    if (!audioContext) {
                        try {
                            window.AudioContext = window.AudioContext || window.webkitAudioContext;
                            audioContext = new AudioContext();
                        } catch (e) {
                            console.error('Web Audio API not supported');
                            return;
                        }
                    }

                    // Initial scrub to current position
                    updateScrubPosition(e);

                    // Prevent text selection during drag
                    e.preventDefault();
                });

                // Handle scrubbing movement
                overlay.addEventListener('mousemove', function (e) {
                    if (!isScrubbing || !audioBuffer) return;
                    updateScrubPosition(e);
                });

                // Function to update position during scrubbing
                function updateScrubPosition(e) {
                    const rect = overlay.getBoundingClientRect();
                    const y = e.clientY - rect.top;
                    const percentage = Math.max(0, Math.min(1, y / rect.height));

                    // Calculate time point in the audio
                    const timePoint = percentage * audioBuffer.duration;
                    startOffset = timePoint;

                    // Update audio scrubber
                    audioScrubber.value = percentage * 100;

                    // Play a short snippet of audio at this position
                    playScrubAudio(timePoint);

                    // Update the marker
                    updateFrameMarker();
                }

                // End scrubbing when mouse is released or leaves element
                overlay.addEventListener('mouseup', function () {
                    isScrubbing = false;
                });

                overlay.addEventListener('mouseleave', function () {
                    isScrubbing = false;
                });

                // Function to play a short snippet at the scrub position
                let scrubSource = null;
                function playScrubAudio(timePoint) {
                    if (scrubSource) {
                        try {
                            scrubSource.stop();
                        } catch (e) {
                            // Ignore errors when stopping already stopped source
                        }
                    }

                    // Play a very short snippet at the current position
                    scrubSource = audioContext.createBufferSource();
                    scrubSource.buffer = audioBuffer;
                    scrubSource.connect(audioContext.destination);

                    // Play just a short snippet (equivalent to 1-2 frames at 24fps)
                    const snippetDuration = 1 / 12; // 1/12 of a second (2 frames at 24fps)
                    scrubSource.start(0, timePoint, snippetDuration);
                }

                // Right-click to add phonetic marker
                overlay.addEventListener('contextmenu', function (e) {
                    e.preventDefault();
                    if (!audioBuffer) return;

                    const rect = overlay.getBoundingClientRect();
                    const y = e.clientY - rect.top;
                    const percentage = y / rect.height;

                    // Calculate time point in the audio
                    const timePoint = percentage * audioBuffer.duration;

                    showPhoneticInput(timePoint);
                    return false;
                });

                waveformContainer.appendChild(overlay);

                // Add the container to the table
                document.body.appendChild(waveformContainer);

                // Position the container over the waveform column
                const tableRect = table.getBoundingClientRect();
                const cellRect = firstCell.getBoundingClientRect();

                waveformContainer.style.left = (cellRect.left - 1) + 'px';
                waveformContainer.style.top = (cellRect.top) + 'px';
                waveformContainer.style.width = (cellRect.width) + 'px';
                waveformContainer.style.height = totalHeight + 'px';

                // Draw the waveform on the canvas
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                // Clear and set background
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);

                // Calculate scaling factors
                const totalDuration = audioBuffer.duration;
                const framesPerSecond = 24;
                const totalFrames = Math.ceil(totalDuration * framesPerSecond);

                // Draw center line
                ctx.beginPath();
                ctx.strokeStyle = '#cccccc';
                ctx.moveTo(width / 2, 0);
                ctx.lineTo(width / 2, height);
                ctx.stroke();

                // Draw the waveform
                ctx.beginPath();
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;

                // Map waveform data to vertical height
                for (let i = 0; i < waveformData.length; i++) {
                    const y = (i / waveformData.length) * height;
                    const amplitude = waveformData[i] * (width * 0.4); // Scale amplitude to 40% of width
                    const x = (width / 2) + amplitude;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                // Draw mirrored waveform for visual effect
                for (let i = waveformData.length - 1; i >= 0; i--) {
                    const y = (i / waveformData.length) * height;
                    const amplitude = waveformData[i] * (width * 0.4);
                    const x = (width / 2) - amplitude;

                    ctx.lineTo(x, y);
                }

                ctx.stroke();

                // Draw frame markers
                for (let i = 1; i <= totalFrames && i <= totalRows; i++) {
                    const y = (i / totalRows) * height;

                    // Draw horizontal line at frame boundary
                    if (i % 8 === 0) {
                        ctx.beginPath();
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 1;
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }
                }

                // Render phonetic markers
                renderPhoneticMarkers();

                // Add the moving marker for current frame
                updateFrameMarker();
            }

            function renderPhoneticMarkers() {
                if (!phonetics || !audioBuffer) return;

                // Get the waveform container
                const waveformContainer = document.querySelector('.waveform-container');
                if (!waveformContainer) return;

                // Get container dimensions
                const containerHeight = waveformContainer.offsetHeight;

                // Add phonetic markers
                phonetics.forEach(phonetic => {
                    // Calculate vertical position based on time
                    const percentage = phonetic.time / audioBuffer.duration;
                    const yPosition = percentage * containerHeight;

                    // Create and position the marker
                    const label = document.createElement('div');
                    label.className = 'phonetic-label';
                    label.textContent = phonetic.text;
                    label.style.position = 'absolute';
                    label.style.left = '2px';
                    label.style.top = yPosition + 'px';
                    label.style.zIndex = '25';

                    // Add event listener to edit the phonetic marker
                    label.addEventListener('dblclick', function () {
                        showPhoneticInput(phonetic.time, phonetic.text, phonetics.indexOf(phonetic));
                    });

                    waveformContainer.appendChild(label);
                });
            }

            function updateFrameMarker() {
                if (!audioBuffer) return;

                // Remove existing markers
                const existingMarkers = document.querySelectorAll('.waveform-marker');
                existingMarkers.forEach(marker => marker.remove());

                // Calculate which frame we're on
                const time = isPlaying ?
                    (audioContext.currentTime - startTime + startOffset) :
                    startOffset;

                const frame = Math.floor(time / frameDuration) + 1;
                currentFrame = frame;

                // Get the waveform container
                const waveformContainer = document.querySelector('.waveform-container');
                if (!waveformContainer) return;

                // Calculate vertical position based on time
                const containerHeight = waveformContainer.offsetHeight;
                const percentage = time / audioBuffer.duration;
                const yPosition = percentage * containerHeight;

                // Create horizontal marker line
                const marker = document.createElement('div');
                marker.className = 'waveform-marker';
                marker.style.position = 'absolute';
                marker.style.top = yPosition + 'px';
                marker.style.left = '0';
                marker.style.width = '100%';
                marker.style.height = '2px';
                marker.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
                marker.style.zIndex = '30';

                // Add frame number
                marker.textContent = `Frame ${frame}`;
                marker.style.lineHeight = '0';
                marker.style.textAlign = 'right';
                marker.style.color = 'red';
                marker.style.fontWeight = 'bold';
                marker.style.fontSize = '8pt';

                waveformContainer.appendChild(marker);

                // Scroll to the marker if it's not visible and if we're playing
                if (isPlaying) {
                    const table = document.getElementById('xsheet-table');
                    const tableRect = table.getBoundingClientRect();
                    const markerY = tableRect.top + yPosition;

                    // Check if marker is outside visible area
                    if (markerY < window.scrollY || markerY > window.scrollY + window.innerHeight) {
                        window.scrollTo({
                            top: markerY - (window.innerHeight / 2),
                            behavior: 'smooth'
                        });
                    }
                }

                // Update scrubber position
                if (audioBuffer) {
                    const scrubPercentage = (time / audioBuffer.duration) * 100;
                    audioScrubber.value = scrubPercentage;
                }

                // If playing, schedule the next update
                if (isPlaying) {
                    requestAnimationFrame(updateFrameMarker);
                }
            }

            function togglePlayAudio() {
                if (isPlaying) {
                    pauseAudio();
                } else {
                    playAudio();
                }
            }

            function playAudio() {
                if (!audioBuffer) return;

                try {
                    // Create a new source node
                    audioSource = audioContext.createBufferSource();
                    audioSource.buffer = audioBuffer;
                    audioSource.connect(audioContext.destination);

                    // Calculate start position
                    startTime = audioContext.currentTime;

                    // Start playback from the current offset
                    audioSource.start(0, startOffset);
                    isPlaying = true;

                    // Set up animation loop
                    updateFrameMarker();

                    // Update UI
                    playAudioButton.textContent = 'Pause';

                    // Set up ended event
                    audioSource.onended = function () {
                        if (isPlaying) {
                            stopAudio();
                        }
                    };
                } catch (e) {
                    updateStatusMessage('Error playing audio: ' + e.message);
                }
            }

            function pauseAudio() {
                if (!isPlaying || !audioSource) return;

                // Stop the audio
                audioSource.stop();

                // Calculate current position
                startOffset += audioContext.currentTime - startTime;

                isPlaying = false;

                // Update UI
                playAudioButton.textContent = 'Play';
            }

            function stopAudio() {
                if (audioSource) {
                    try {
                        audioSource.stop();
                    } catch (e) {
                        // Ignore errors when stopping already stopped source
                    }
                }

                isPlaying = false;
                startOffset = 0;

                // Update UI
                playAudioButton.textContent = 'Play';
                audioScrubber.value = 0;

                // Clear frame marker
                updateFrameMarker();
            }

            function scrubAudio() {
                if (!audioBuffer) return;

                // Calculate time from scrubber position
                const percentage = audioScrubber.value / 100;
                const newTime = percentage * audioBuffer.duration;

                // If playing, restart from new position
                if (isPlaying) {
                    pauseAudio();
                    startOffset = newTime;
                    playAudio();
                } else {
                    startOffset = newTime;
                    updateFrameMarker();
                }
            }

            function showPhoneticInput(time, initialText = '', editIndex = -1) {
                if (time === null) {
                    // If no time provided, use current position
                    time = isPlaying ?
                        (audioContext.currentTime - startTime + startOffset) :
                        startOffset;
                }

                // Store position for later use
                phoneticEditPosition = {
                    time: time,
                    editIndex: editIndex
                };

                // Set initial text if editing existing marker
                phoneticText.value = initialText;

                // Get the waveform container and calculate position
                const waveformContainer = document.querySelector('.waveform-container');
                if (waveformContainer) {
                    const containerRect = waveformContainer.getBoundingClientRect();
                    const containerHeight = waveformContainer.offsetHeight;
                    const percentage = time / audioBuffer.duration;
                    const yPosition = percentage * containerHeight;

                    // Position the input near the click position
                    phoneticInput.style.top = (containerRect.top + yPosition + window.scrollY) + 'px';
                    phoneticInput.style.left = (containerRect.right + window.scrollX + 5) + 'px';
                } else {
                    // Default position if container not found
                    phoneticInput.style.top = '200px';
                    phoneticInput.style.left = '200px';
                }

                // Show the input and focus it
                phoneticInput.style.display = 'block';
                phoneticText.focus();
            }

            function savePhoneticMarker() {
                if (!phoneticEditPosition) return;

                const text = phoneticText.value.trim();
                if (text === '') {
                    // If empty text and editing an existing marker, remove it
                    if (phoneticEditPosition.editIndex >= 0) {
                        phonetics.splice(phoneticEditPosition.editIndex, 1);
                    }
                } else {
                    // Save or update the phonetic marker
                    if (phoneticEditPosition.editIndex >= 0) {
                        // Update existing
                        phonetics[phoneticEditPosition.editIndex].text = text;
                    } else {
                        // Add new
                        phonetics.push({
                            time: phoneticEditPosition.time,
                            text: text
                        });
                    }
                }

                // Hide input
                phoneticInput.style.display = 'none';

                // Re-render markers
                renderWaveform();

                // Mark as modified
                modified = true;
            }

            function collectData() {
                const data = {
                    template: currentTemplate,
                    frameCount: frameCount,
                    metadata: {
                        projectNumber: document.getElementById('project-number').value,
                        date: document.getElementById('project-date').value,
                        pageNumber: document.getElementById('page-number').value,
                        animatorName: document.getElementById('animator-name').value,
                        versionNumber: document.getElementById('version-number').value,
                        shotNumber: document.getElementById('shot-number').value
                    },
                    audio: {
                        fileName: audioFileName,
                        phonetics: phonetics
                    },
                    rows: []
                };

                // Collect data from all rows
                const rows = tableBody.querySelectorAll('tr');
                rows.forEach(row => {
                    const rowData = {
                        action: row.cells[0].innerText,
                        frame: row.cells[1].innerText,
                        // Skip waveform cell (2)
                        dialogue: row.cells[3].innerText,
                        sound: row.cells[4].innerText,
                        technical: row.cells[5].innerText,
                        extra1: row.cells[6].innerText,
                        extra2: row.cells[7].innerText,
                        frameRepeat: row.cells[8].innerText,
                        camera: row.cells[9].innerText
                    };
                    data.rows.push(rowData);
                });

                return data;
            }

            function restoreData(data) {
                if (!data) return;

                // Update template and frame count
                currentTemplate = data.template || 'large';
                frameCount = data.frameCount || 96;

                // Update UI to match
                templateSelector.value = currentTemplate;
                frameCountInput.value = frameCount;

                // Restore metadata
                if (data.metadata) {
                    document.getElementById('project-number').value = data.metadata.projectNumber || '';
                    document.getElementById('project-date').value = data.metadata.date || '';
                    document.getElementById('page-number').value = data.metadata.pageNumber || '';
                    document.getElementById('animator-name').value = data.metadata.animatorName || '';
                    document.getElementById('version-number').value = data.metadata.versionNumber || '';
                    document.getElementById('shot-number').value = data.metadata.shotNumber || '';
                }

                // Generate the table with the right frame count
                generateTable(frameCount);
                updateTemplate();

                // Restore audio data
                if (data.audio) {
                    audioFileName = data.audio.fileName || '';
                    phonetics = data.audio.phonetics || [];

                    if (audioBuffer && phonetics.length > 0) {
                        renderWaveform();
                    }
                }

                // Restore row data
                if (data.rows && data.rows.length > 0) {
                    const rows = tableBody.querySelectorAll('tr');
                    data.rows.forEach((rowData, index) => {
                        if (index < rows.length) {
                            rows[index].cells[0].innerText = rowData.action || '';
                            // Don't restore frame number cells as they're auto-generated
                            rows[index].cells[3].innerText = rowData.dialogue || '';
                            rows[index].cells[4].innerText = rowData.sound || '';
                            rows[index].cells[5].innerText = rowData.technical || '';
                            rows[index].cells[6].innerText = rowData.extra1 || '';
                            rows[index].cells[7].innerText = rowData.extra2 || '';
                            // Don't restore the second frame number cell
                            rows[index].cells[9].innerText = rowData.camera || '';
                        }
                    });
                }

                modified = false;
                updateStatusMessage('Project loaded successfully');
            }

            function saveProject() {
                const data = collectData();

                // Save to localStorage
                try {
                    localStorage.setItem('animationXSheet', JSON.stringify(data));
                    modified = false;
                    updateStatusMessage('Project saved successfully');

                    // Also download as JSON file for backup
                    const filename = projectName + '.json';
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", filename);
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                } catch (e) {
                    updateStatusMessage('Error saving project: ' + e.message);
                }
            }

            function loadProject() {
                // First try to load from localStorage
                try {
                    const savedData = localStorage.getItem('animationXSheet');
                    if (savedData) {
                        restoreData(JSON.parse(savedData));
                        return;
                    }
                } catch (e) {
                    updateStatusMessage('Error loading saved project: ' + e.message);
                }

                // If no localStorage data, create file input for uploading JSON
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                fileInput.style.display = 'none';
                document.body.appendChild(fileInput);

                fileInput.addEventListener('change', function (e) {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = function (e) {
                        try {
                            const data = JSON.parse(e.target.result);
                            restoreData(data);
                        } catch (error) {
                            updateStatusMessage('Error parsing file: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                });

                fileInput.click();
                fileInput.remove();
            }

            function exportToPDF() {
                // Save the current state before PDF export
                const savedData = collectData();

                updateStatusMessage('Preparing PDF. Please wait...');

                // Remove controls temporarily for PDF generation
                const controls = document.querySelector('.controls');
                const audioControls = document.querySelector('#audio-controls');
                const statusMsg = document.querySelector('.status');
                const phoneticInputEl = document.querySelector('#phonetic-input');

                controls.style.display = 'none';
                audioControls.style.display = 'none';
                statusMsg.style.display = 'none';
                phoneticInputEl.style.display = 'none';

                // Clean up any previous waveform elements
                const previousContainers = document.querySelectorAll('.cell-waveform-window');
                previousContainers.forEach(container => container.remove());

                // Draw the waveform directly into the cells
                if (audioBuffer && waveformData.length > 0) {
                    drawWaveformInCells();
                }

                // Wait a moment for DOM updates to complete
                setTimeout(() => {
                    try {
                        // Use html2canvas to capture the printable area
                        html2canvas(document.getElementById('printable-area'), {
                            scale: 2, // Higher resolution
                            useCORS: true,
                            logging: false,
                            allowTaint: true
                        }).then(canvas => {
                            const imgData = canvas.toDataURL('image/png');

                            // Determine PDF size based on template
                            let pdfWidth, pdfHeight;
                            if (currentTemplate === 'large') {
                                // 11"x17"
                                pdfWidth = 279.4; // mm
                                pdfHeight = 431.8; // mm
                            } else {
                                // 8.5"x11"
                                pdfWidth = 215.9; // mm
                                pdfHeight = 279.4; // mm
                            }

                            // Create PDF with jsPDF
                            const { jsPDF } = window.jspdf;
                            const pdf = new jsPDF({
                                orientation: 'portrait',
                                unit: 'mm',
                                format: [pdfWidth, pdfHeight]
                            });

                            // Calculate aspect ratio
                            const imgWidth = pdfWidth - 20; // margins
                            const imgHeight = canvas.height * imgWidth / canvas.width;

                            // Add image to PDF
                            pdf.addImage(imgData, 'PNG', 10, 10, imgWidth, imgHeight);

                            // Save PDF
                            pdf.save(`${projectName}.pdf`);

                            // Clean up after PDF generation using saved data instead of rebuilding
                            cleanupAfterExport(savedData);
                        });
                    } catch (e) {
                        // Clean up if there was an error
                        cleanupAfterExport(savedData);
                        updateStatusMessage('Error exporting PDF: ' + e.message);
                    }
                }, 100);

                function cleanupAfterExport(savedData) {
                    // Restore controls
                    controls.style.display = 'flex';
                    audioControls.style.display = 'flex';
                    statusMsg.style.display = 'block';

                    // Restore data instead of regenerating blank table
                    restoreData(savedData);

                    updateStatusMessage('PDF exported successfully');
                }

                function drawWaveformInCells() {
                    const waveformCells = document.querySelectorAll('.waveform-col');
                    if (waveformCells.length === 0) return;

                    // Calculate the number of data points per frame
                    const totalDuration = audioBuffer.duration;
                    const pointsPerFrame = waveformData.length / (totalDuration * 24);

                    // For each cell, draw its portion of the waveform
                    waveformCells.forEach((cell, index) => {
                        // Get the frame number (1-based)
                        const frameNum = index + 1;

                        // Create a canvas for this cell
                        const canvas = document.createElement('canvas');
                        canvas.width = cell.offsetWidth;
                        canvas.height = cell.offsetHeight;
                        canvas.style.display = 'block';
                        canvas.style.width = '100%';
                        canvas.style.height = '100%';

                        const ctx = canvas.getContext('2d');

                        // Fill with white background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // Draw center line
                        ctx.beginPath();
                        ctx.strokeStyle = '#cccccc';
                        ctx.moveTo(canvas.width / 2, 0);
                        ctx.lineTo(canvas.width / 2, canvas.height);
                        ctx.stroke();

                        // Calculate which section of the waveform to draw
                        const startPoint = Math.floor((frameNum - 1) * pointsPerFrame);
                        const endPoint = Math.floor(frameNum * pointsPerFrame);

                        if (startPoint < waveformData.length) {
                            // Draw this portion of the waveform
                            ctx.beginPath();
                            ctx.strokeStyle = '#000000';

                            // Check if we have valid data to draw
                            if (endPoint > startPoint) {
                                // Map the waveform section to this cell
                                for (let i = startPoint; i <= endPoint && i < waveformData.length; i++) {
                                    // Calculate position within this cell
                                    const relativePos = (i - startPoint) / (endPoint - startPoint);
                                    const y = relativePos * canvas.height;

                                    // Draw waveform
                                    const amplitude = waveformData[i] * (canvas.width * 0.4);
                                    const x = (canvas.width / 2) + amplitude;

                                    if (i === startPoint) {
                                        ctx.moveTo(x, y);
                                    } else {
                                        ctx.lineTo(x, y);
                                    }
                                }

                                // Draw left side (mirror)
                                for (let i = endPoint; i >= startPoint && i < waveformData.length; i--) {
                                    const relativePos = (i - startPoint) / (endPoint - startPoint);
                                    const y = relativePos * canvas.height;

                                    const amplitude = waveformData[i] * (canvas.width * 0.4);
                                    const x = (canvas.width / 2) - amplitude;

                                    ctx.lineTo(x, y);
                                }

                                ctx.stroke();
                            }

                            // Look for phonetic markers that might be in this frame
                            if (phonetics && phonetics.length > 0) {
                                phonetics.forEach(phonetic => {
                                    // Calculate which frame this phonetic marker belongs to
                                    const frameOfMarker = Math.floor(phonetic.time / frameDuration) + 1;

                                    // If it's in this frame, draw it
                                    if (frameOfMarker === frameNum) {
                                        // Calculate position within cell
                                        const posInFrameRatio = (phonetic.time - ((frameNum - 1) * frameDuration)) / frameDuration;
                                        const yPos = posInFrameRatio * canvas.height;

                                        // Draw marker line
                                        ctx.beginPath();
                                        ctx.strokeStyle = '#ff0000';
                                        ctx.lineWidth = 1;
                                        ctx.moveTo(0, yPos);
                                        ctx.lineTo(canvas.width, yPos);
                                        ctx.stroke();

                                        // Add label if it fits
                                        if (canvas.width > 30) {
                                            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                                            const textWidth = ctx.measureText(phonetic.text).width;
                                            if (textWidth < canvas.width - 4) {
                                                ctx.fillRect(2, yPos - 8, textWidth + 4, 14);
                                                ctx.fillStyle = '#ff0000';
                                                ctx.font = '8px Arial';
                                                ctx.fillText(phonetic.text, 4, yPos + 4);
                                            }
                                        }
                                    }
                                });
                            }
                        }

                        // Add frame number indicator
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.fillRect(0, 0, 18, 12);
                        ctx.fillStyle = '#000000';
                        ctx.font = '8px Arial';
                        ctx.fillText(frameNum, 2, 8);

                        // Clear cell content and add the canvas
                        cell.innerHTML = '';
                        cell.appendChild(canvas);
                    });
                }
            }

            function printSheet() {
                updateStatusMessage('Preparing to print. Please wait...');

                // Save current selection state and cell contents
                const tableData = saveSelectionState();

                // Hide the waveform container temporarily but don't remove it
                const originalWf = document.querySelector('.waveform-container');
                if (originalWf) {
                    originalWf.style.display = 'none';
                }

                // Draw the waveform directly into the cells before printing
                if (audioBuffer && waveformData.length > 0) {
                    drawWaveformInCells();
                }

                // Wait a moment for DOM updates to complete
                setTimeout(() => {
                    window.print();

                    // Clean up after printing
                    setTimeout(() => {
                        // Restore the original waveform container
                        if (originalWf) {
                            originalWf.style.display = '';
                        }

                        // Restore original cell content for waveform cells only
                        const waveformCells = document.querySelectorAll('.waveform-col');
                        waveformCells.forEach(cell => {
                            const originalContent = cell.getAttribute('data-original-content');
                            if (originalContent !== null) {
                                cell.innerHTML = originalContent;
                                cell.removeAttribute('data-original-content');
                            }
                        });

                        // Restore all cell contents from saved data
                        if (tableData && tableData.cellContents) {
                            tableData.cellContents.forEach(cellData => {
                                if (cellData.rowIndex >= 0 && cellData.rowIndex < tableBody.children.length) {
                                    const row = tableBody.children[cellData.rowIndex];
                                    if (cellData.colIndex >= 0 && cellData.colIndex < row.children.length) {
                                        const cell = row.children[cellData.colIndex];

                                        // Skip waveform cells (they were already restored above)
                                        if (!cell.classList.contains('waveform-col')) {
                                            // Only restore if cell is editable
                                            if (cell.contentEditable === 'true') {
                                                cell.innerHTML = cellData.content;

                                                // Restore modified status
                                                if (cellData.isModified) {
                                                    cell.classList.add('modified');
                                                } else {
                                                    cell.classList.remove('modified');
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        // Restore metadata fields
                        if (tableData && tableData.metadata) {
                            document.getElementById('project-number').value = tableData.metadata.projectNumber || '';
                            document.getElementById('project-date').value = tableData.metadata.date || '';
                            document.getElementById('page-number').value = tableData.metadata.pageNumber || '';
                            document.getElementById('animator-name').value = tableData.metadata.animatorName || '';
                            document.getElementById('version-number').value = tableData.metadata.versionNumber || '';
                            document.getElementById('shot-number').value = tableData.metadata.shotNumber || '';
                        }

                        // Finally restore cell selection state
                        restoreSelectionState(tableData);

                        updateStatusMessage('Print complete');
                    }, 500);
                }, 100);

                function drawWaveformInCells() {
                    const waveformCells = document.querySelectorAll('.waveform-col');
                    if (waveformCells.length === 0) return;

                    // Calculate the number of data points per frame
                    const totalDuration = audioBuffer.duration;
                    const pointsPerFrame = waveformData.length / (totalDuration * 24);

                    // For each cell, draw its portion of the waveform
                    waveformCells.forEach((cell, index) => {
                        // Get the frame number (1-based)
                        const frameNum = index + 1;

                        // Create a canvas for this cell
                        const canvas = document.createElement('canvas');
                        canvas.width = cell.offsetWidth;
                        canvas.height = cell.offsetHeight;
                        canvas.style.display = 'block';
                        canvas.style.width = '100%';
                        canvas.style.height = '100%';

                        const ctx = canvas.getContext('2d');

                        // Fill with white background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // Draw center line
                        ctx.beginPath();
                        ctx.strokeStyle = '#cccccc';
                        ctx.moveTo(canvas.width / 2, 0);
                        ctx.lineTo(canvas.width / 2, canvas.height);
                        ctx.stroke();

                        // Calculate which section of the waveform to draw
                        const startPoint = Math.floor((frameNum - 1) * pointsPerFrame);
                        const endPoint = Math.floor(frameNum * pointsPerFrame);

                        if (startPoint < waveformData.length) {
                            // Draw this portion of the waveform
                            ctx.beginPath();
                            ctx.strokeStyle = '#000000';

                            // Check if we have valid data to draw
                            if (endPoint > startPoint) {
                                // Map the waveform section to this cell
                                for (let i = startPoint; i <= endPoint && i < waveformData.length; i++) {
                                    // Calculate position within this cell
                                    const relativePos = (i - startPoint) / (endPoint - startPoint);
                                    const y = relativePos * canvas.height;

                                    // Draw waveform
                                    const amplitude = waveformData[i] * (canvas.width * 0.4);
                                    const x = (canvas.width / 2) + amplitude;

                                    if (i === startPoint) {
                                        ctx.moveTo(x, y);
                                    } else {
                                        ctx.lineTo(x, y);
                                    }
                                }

                                // Draw left side (mirror)
                                for (let i = endPoint; i >= startPoint && i < waveformData.length; i--) {
                                    const relativePos = (i - startPoint) / (endPoint - startPoint);
                                    const y = relativePos * canvas.height;

                                    const amplitude = waveformData[i] * (canvas.width * 0.4);
                                    const x = (canvas.width / 2) - amplitude;

                                    ctx.lineTo(x, y);
                                }

                                ctx.stroke();
                            }

                            // Look for phonetic markers that might be in this frame
                            if (phonetics && phonetics.length > 0) {
                                phonetics.forEach(phonetic => {
                                    // Calculate which frame this phonetic marker belongs to
                                    const frameOfMarker = Math.floor(phonetic.time / frameDuration) + 1;

                                    // If it's in this frame, draw it
                                    if (frameOfMarker === frameNum) {
                                        // Calculate position within cell
                                        const posInFrameRatio = (phonetic.time - ((frameNum - 1) * frameDuration)) / frameDuration;
                                        const yPos = posInFrameRatio * canvas.height;

                                        // Draw marker line
                                        ctx.beginPath();
                                        ctx.strokeStyle = '#ff0000';
                                        ctx.lineWidth = 1;
                                        ctx.moveTo(0, yPos);
                                        ctx.lineTo(canvas.width, yPos);
                                        ctx.stroke();

                                        // Add label if it fits
                                        if (canvas.width > 30) {
                                            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                                            const textWidth = ctx.measureText(phonetic.text).width;
                                            if (textWidth < canvas.width - 4) {
                                                ctx.fillRect(2, yPos - 8, textWidth + 4, 14);
                                                ctx.fillStyle = '#ff0000';
                                                ctx.font = '8px Arial';
                                                ctx.fillText(phonetic.text, 4, yPos + 4);
                                            }
                                        }
                                    }
                                });
                            }
                        }

                        // Add frame number indicator
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.fillRect(0, 0, 18, 12);
                        ctx.fillStyle = '#000000';
                        ctx.font = '8px Arial';
                        ctx.fillText(frameNum, 2, 8);

                        // Store original content and add the canvas
                        cell.setAttribute('data-original-content', cell.innerHTML);
                        cell.innerHTML = '';
                        cell.appendChild(canvas);
                    });
                }

                function saveSelectionState() {
                    // Save current selection and cell contents
                    const tableData = {
                        // Save which cells are selected
                        selectedIndices: selectedCells.map(cell => {
                            const row = cell.closest('tr');
                            const rowIndex = Array.from(tableBody.children).indexOf(row);
                            const colIndex = Array.from(row.children).indexOf(cell);
                            return { rowIndex, colIndex };
                        }),
                        // Save metadata fields
                        metadata: {
                            projectNumber: document.getElementById('project-number').value,
                            date: document.getElementById('project-date').value,
                            pageNumber: document.getElementById('page-number').value,
                            animatorName: document.getElementById('animator-name').value,
                            versionNumber: document.getElementById('version-number').value,
                            shotNumber: document.getElementById('shot-number').value
                        },
                        // Store editable cells' content
                        cellContents: []
                    };

                    // Store all editable cells' content
                    const allEditableCells = document.querySelectorAll('[contenteditable="true"]');
                    allEditableCells.forEach(cell => {
                        const row = cell.closest('tr');
                        if (row) {
                            const rowIndex = Array.from(tableBody.children).indexOf(row);
                            const colIndex = Array.from(row.children).indexOf(cell);
                            tableData.cellContents.push({
                                rowIndex,
                                colIndex,
                                content: cell.innerHTML,
                                isModified: cell.classList.contains('modified')
                            });
                        }
                    });

                    return tableData;
                }

                function restoreSelectionState(tableData) {
                    if (!tableData || !tableData.selectedIndices) return;

                    // Clear current selection
                    clearCellSelection();

                    // Restore selection
                    tableData.selectedIndices.forEach(index => {
                        if (index.rowIndex >= 0 && index.rowIndex < tableBody.children.length) {
                            const row = tableBody.children[index.rowIndex];
                            if (index.colIndex >= 0 && index.colIndex < row.children.length) {
                                const cell = row.children[index.colIndex];
                                if (cell.contentEditable === 'true') {
                                    toggleCellSelection(cell, true);
                                }
                            }
                        }
                    });
                }
            }

            function addEightRows() {
                frameCount += 8;
                frameCountInput.value = frameCount;
                generateTable(frameCount);
                updateStatusMessage('Added 8 rows. Total frames: ' + frameCount);

                // Re-render waveform if audio is loaded
                if (audioBuffer) {
                    renderWaveform();
                }
            }

            function clearSheet() {
                if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                    // Clear metadata
                    document.getElementById('project-number').value = '';
                    document.getElementById('page-number').value = '';
                    document.getElementById('animator-name').value = '';
                    document.getElementById('version-number').value = '';
                    document.getElementById('shot-number').value = '';

                    // Reset date to today
                    document.getElementById('project-date').valueAsDate = new Date();

                    // Clear all editable cells
                    const editableCells = document.querySelectorAll('[contenteditable="true"]');
                    editableCells.forEach(cell => {
                        cell.innerText = '';
                        cell.classList.remove('modified');
                    });

                    // Clear audio
                    audioBuffer = null;
                    audioSource = null;
                    waveformData = [];
                    phonetics = [];
                    audioFileName = '';
                    audioInfo.textContent = 'No audio loaded';

                    // Stop any playing audio
                    stopAudio();

                    // Clear waveform visualization
                    waveformCanvases.forEach(canvas => {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    });

                    // Clear phonetic markers
                    const labels = document.querySelectorAll('.phonetic-label');
                    labels.forEach(label => label.remove());
                    
                    // Clear drawings
                    if (window.xsheetDrawing && window.xsheetDrawing.layerSystem) {
                        window.xsheetDrawing.layerSystem.clearAllLayers();
                    }

                    modified = false;
                    updateStatusMessage('Sheet cleared');
                }
            }

            function updateStatusMessage(message) {
                statusMessage.textContent = message;
                console.log(message);

                // Clear status message after 3 seconds
                setTimeout(() => {
                    if (statusMessage.textContent === message) {
                        if (modified) {
                            statusMessage.textContent = 'Unsaved changes';
                        } else {
                            statusMessage.textContent = '';
                        }
                    }
                }, 3000);
            }

            // Auto-save timer every 2 minutes
            setInterval(() => {
                if (modified) {
                    try {
                        const data = collectData();
                        localStorage.setItem('animationXSheet_autosave', JSON.stringify(data));
                        updateStatusMessage('Auto-saved');
                    } catch (e) {
                        console.error('Auto-save failed:', e);
                    }
                }
            }, 120000);

            // Check for auto-saved data on load
            try {
                const autoSavedData = localStorage.getItem('animationXSheet_autosave');
                if (autoSavedData && !localStorage.getItem('animationXSheet')) {
                    if (confirm('Found auto-saved data. Would you like to restore it?')) {
                        restoreData(JSON.parse(autoSavedData));
                    }
                }
            } catch (e) {
                console.error('Error checking for auto-saved data:', e);
            }

            // Initial status
            updateStatusMessage('X-Sheet ready');
        });
    </script>
</body>

</html>